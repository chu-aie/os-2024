# 스케줄링: 멀티 레벨 피드백 큐[^Jo-Sehyun]

[^Jo-Sehyun]: [조세현](https://github.com/Jo-Sehyun)

멀티 레벨 피드백 큐(Multi-Level Feedback Queue, MLFQ) 스케줄러는 1962년 Corbato 등에 의해 CTSS(Compatible Time-Sharing System)에 처음 도입되었습니다. Corbato는 이 연구와 Multics에 대한 후속 연구로 최고 권위의 튜링상을 수상했죠. 이후 MLFQ는 수년에 걸쳐 발전을 거듭하며 오늘날의 몇몇 현대 시스템에까지 이르게 되었습니다.

MLFQ가 해결하고자 하는 핵심 문제는 두 가지입니다.

1. 짧은 작업을 우선 처리하여 반환 시간(turnaround time)을 최적화하는 것입니다. SJF나 STCF 같은 알고리즘은 이를 위해 각 작업의 실행 시간 정보를 필요로 하지만, 안타깝게도 운영체제는 이 정보를 사전에 알 수 없습니다.

2. 사용자와 상호작용하는 프로세스, 즉 사용자가 화면 앞에서 응답을 기다리는 프로세스의 응답 시간(response time)을 최소화하는 것입니다. RR 같은 알고리즘은 응답 시간을 어느 정도 단축시키지만, 반환 시간 측면에서는 거의 최악에 가까운 성능을 보입니다.

```{note}
라운드 로빈(Round Robin, RR)은 프로세스들에게 CPU 사용 시간을 공평하게 분배하는 스케줄링 알고리즘입니다.

RR에서는 각 프로세스가 동일한 시간 할당량(타임 슬라이스)을 받습니다. 할당된 시간이 끝나면 프로세스는 선점(preemption)되고, 준비 큐(ready queue)의 맨 뒤로 보내집니다. 그러면 큐의 다음 프로세스가 CPU를 받아 실행되는 식이죠.

이런 방식으로 모든 프로세스가 돌아가면서 CPU를 사용하게 됩니다. 마치 원탁에 앉은 사람들이 돌아가며 말하는 것과 비슷하다고 해서 '라운드 로빈'이라는 이름이 붙었습니다.

RR의 주요 특징은 다음과 같습니다:

1. 모든 프로세스는 동일한 타임 슬라이스를 할당받습니다.

2. CPU 버스트가 타임 슬라이스보다 짧으면 프로세스는 자발적으로 CPU를 양보합니다.

3. CPU 버스트가 타임 슬라이스보다 길면 타임 슬라이스가 끝난 후 프로세스는 선점됩니다.

4. 선점된 프로세스는 준비 큐의 맨 뒤로 가서 다시 CPU를 기다립니다.

RR은 대화형 시스템에서 응답 시간을 줄이는 데 효과적입니다. 모든 프로세스가 CPU를 조금씩 나눠 쓰기 때문에 어느 한 프로세스가 지나치게 오래 기다리는 일이 없거든요. 하지만 문맥 교환(context switch) 오버헤드가 있고, 타임 슬라이스가 너무 작으면 오히려 성능이 저하될 수 있다는 단점도 있습니다.
```

여기서 우리가 마주하는 질문은 이렇습니다.

- 개별 프로세스에 대한 사전 정보가 전혀 없는 상황에서 이런 스케줄러를 어떻게 만들 수 있을까요?

- 프로세스가 실행되는 동안 그 특성을 파악하고, 이를 토대로 더 나은 스케줄링 결정을 내리려면 어떤 방법을 사용할 수 있을까요?

```{admonition} 핵심 질문: 정보 없이 스케줄링하는 방법은?
프로세스의 실행 시간을 미리 알 수 없는 상황에서, 대화형 프로세스의 응답 시간을 최소화하면서 동시에 전체 반환 시간도 최소화할 수 있는 스케줄러를 어떻게 설계할 수 있을까요?
```

MLFQ는 바로 이 문제에 도전하기 위해 고안된 스케줄링 기법입니다. 프로세스의 실행 특성을 관찰하고 그에 따라 동적으로 우선순위를 조정함으로써, 사전 정보 없이도 최적에 가까운 스케줄링을 달성하고자 하는 것이죠.

## MLFQ: 기본 규칙

## 멀티 레벨 피드백 큐: 기본 규칙

멀티 레벨 피드백 큐(MLFQ)의 기본 알고리즘은 다음과 같습니다. 세부 사항에서는 차이가 있을 수 있지만, 대부분의 MLFQ 구현체는 이와 유사한 원리를 따릅니다.

MLFQ는 여러 개의 큐로 이루어져 있으며, 각 큐는 서로 다른 우선순위(priority level)를 갖습니다. 실행 가능한 모든 프로세스는 이 큐들 중 하나에 위치하게 됩니다. MLFQ는 우선순위에 따라 다음에 실행할 프로세스를 선택하는데, 보다 높은 우선순위의 큐에 있는 프로세스가 우선적으로 선택됩니다.

```{admonition} 팁: 과거에서 배우다
MLFQ는 과거의 행동 패턴을 토대로 미래를 예측하는 좋은 예시입니다. 이런 접근법은 운영체제를 비롯한 컴퓨터 과학의 여러 분야(하드웨어의 분기 예측이나 캐시 알고리즘 등)에서 자주 사용됩니다. 이 방식은 작업의 진행 양상이 단계적이고 예측 가능할 때 효과적입니다. 다만 주의해서 사용해야 합니다. 잘못 적용하면 오히려 예측 정보가 없을 때보다 더 안 좋은 결정을 내릴 수 있기 때문이죠.
```

한 큐에는 여러 프로세스가 존재할 수 있는데, 이들은 모두 동일한 우선순위를 갖습니다. 같은 큐 내의 프로세스들에 대해서는 라운드 로빈(Round-Robin, RR) 스케줄링이 적용됩니다.

MLFQ의 핵심은 바로 이 우선순위를 결정하는 방식에 있습니다. MLFQ는 각 프로세스에 고정된 우선순위를 부여하지 않고, 프로세스의 실행 특성에 따라 동적으로 우선순위를 조정합니다.

예를 들어, 어떤 프로세스가 키보드 입력을 기다리며 반복적으로 CPU를 양보한다면 MLFQ는 그 프로세스의 우선순위를 높게 유지합니다. 이는 대화형 프로세스의 전형적인 행동 양식이기 때문이죠. 반대로 어떤 프로세스가 장시간 CPU를 독점한다면 MLFQ는 그 프로세스의 우선순위를 점차 낮춰갑니다.

이렇게 MLFQ는 프로세스의 실행 도중 그 특성을 파악하고, 이를 토대로 향후 행동을 예측하는 것입니다.

MLFQ의 두 가지 기본 규칙은 다음과 같습니다.

- 규칙 1: Priority(A) > Priority(B) 이면, B는 실행되지 않고 A가 실행됩니다.
- 규칙 2: Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행됩니다.

## 시도 1: 우선순위의 변경

MLFQ는 프로세스의 우선순위를 어떻게 조정할 것인지 결정해야 합니다. 프로세스의 우선순위를 변경한다는 것은 곧 그 프로세스가 위치할 큐를 결정하는 것과 같습니다. 이를 위해서는 시스템의 워크로드 특성을 반영해야 합니다. 일반적으로 워크로드는 짧은 CPU 버스트를 가지며 자주 I/O를 수행하는 대화형 작업과, CPU 시간을 많이 필요로 하지만 응답 시간은 상대적으로 덜 중요한 긴 CPU 버스트의 계산 집약적 작업이 섞여 있습니다.

우선순위 조정을 위한 첫 번째 시도는 다음과 같습니다.

![11_1](https://github.com/chu-aie/os-2024/assets/162019986/8c215acb-dff6-4dff-8fee-03e2f1c0570b)

어떤 한 시점에서 큐의 상태는 그림 11.1과 같을 수 있습니다. 프로세스 A와 B는 가장 높은 우선순위 큐에, C는 중간 큐에, D는 가장 낮은 우선순위 큐에 있습니다. 우리가 알고 있는 MLFQ의 동작 방식에 따르면, 스케줄러는 최상위 큐에 있는 A와 B를 RR 방식으로 번갈아 실행할 것입니다. 다만 이런 정적인 스냅샷만으로는 MLFQ의 실제 동작을 완전히 파악할 수 없습니다.

프로세스의 우선순위가 시간에 따라 어떻게 변화하는지 살펴보겠습니다.

- 규칙 3: 새로운 프로세스가 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 배치된다.

- 규칙 4a: 할당된 타임 슬라이스를 모두 소진하면 해당 프로세스의 우선순위가 한 단계 낮아진다. 즉, 바로 아래 큐로 이동한다.

- 규칙 4b: 타임 슬라이스가 끝나기 전에 스스로 CPU를 양보(yield)하면 같은 우선순위를 유지한다.

여기서 타임 슬라이스(time slice)란 각 프로세스에 할당되는 CPU 사용 시간의 단위를 말합니다. 프로세스가 이 시간을 모두 쓰면 선점(preemption)되고, 자발적으로 양보하면 우선순위가 유지되는 거죠.

이러한 규칙을 통해 MLFQ는 프로세스의 실행 특성에 따라 동적으로 우선순위를 조정합니다. I/O를 많이 수행하는 프로세스는 높은 우선순위를 유지하는 반면, CPU를 오래 사용하는 프로세스는 점차 낮은 우선순위로 이동하게 됩니다.

### 예제 1: 긴 CPU 버스트를 가진 프로세스

이제 몇 가지 예시를 통해 MLFQ가 어떻게 동작하는지 살펴보겠습니다. 먼저, CPU를 오랫동안 사용하는 프로세스가 시스템에 들어왔을 때 어떤 일이 벌어지는지 알아봅시다. 그림 11.2는 3개의 큐로 구성된 MLFQ 스케줄러에서 시간이 지남에 따라 이 프로세스의 우선순위가 어떻게 변화하는지 보여줍니다.

![11_2](https://github.com/chu-aie/os-2024/assets/162019986/148fae3e-7cd2-4307-9eea-63de41acfe2e)

예시에서 볼 수 있듯이, 프로세스는 처음에 최상위 큐인 Q2에 위치합니다(규칙 3). 10ms의 타임 슬라이스를 모두 소진하면, 스케줄러는 이 프로세스의 우선순위를 한 단계 낮춰 Q1으로 이동시킵니다(규칙 4a).

Q1에서도 마찬가지로 타임 슬라이스를 다 쓰면 프로세스는 최하위 큐인 Q0으로 내려갑니다. 이후로는 계속 Q0에 남아있게 되는 거죠.

여기서 주목할 점은 다음과 같습니다:

1. 프로세스는 가장 높은 우선순위에서 시작합니다.
2. 할당된 타임 슬라이스를 모두 쓰면 우선순위가 단계적으로 낮아집니다.
3. 최하위 큐에 도달하면 우선순위의 변동이 없습니다.

이를 통해 우리는 CPU를 많이 사용하는 프로세스가 MLFQ에서 어떻게 처리되는지 알 수 있습니다. 초기에는 높은 우선순위를 받지만, CPU를 계속 점유하면 점차 낮은 큐로 이동하다가 결국 최하위 큐에 머무르게 되는 것이죠. 이렇게 MLFQ는 프로세스의 실행 패턴에 따라 동적으로 우선순위를 조정합니다.

### 예 2: 짧은 작업과 함께

좀 더 복잡한 예를 살펴보겠습니다. MLFQ가 어떻게 SJF에 근접할 수 있는지 이해해야 합니다. 이 예에서는 2개의 작업이 존재합니다. A는 오래 실행되는 CPU 위주 작업이고 B는 짧은 대화형 작업입니다. A는 얼마 동안 이미 실행해 온 상태이고 B는 이제 도착했다고 가정할 때 어떤 일이 벌어질까? MLFQ는 SJF와 근사하게 동작해서 B를 선호할 것인가?

![11 3](https://github.com/chu-aie/os-2024/assets/162019986/6d54f8da-7743-438c-9063-ef7e04cc0db5)

그림 11.3은 이 시나리오의 결과를 보입니다. 다른 오래 실행되는 CPU 위주 작업들처럼 A(검은색)는 가장 낮은 우선순위 큐에서 실행되고 있습니다. B(회색)는 T = 100에 시스템에 도착하고 가장 높은 우선순위 큐에 놓입니다. 실행 시간이 짧기 때문에 (20ms), 두 번의 타임 슬라이스를 소모하면 B는 바닥의 큐에 도착하기 전에 종료합니다. 그런 후에 A는 낮은 우선순위에서 실행을 재개합니다.

이 예에서 이 알고리즘의 주요 목표를 알 수 있습니다. 스케줄러는 작업이 짧은 작업인지 긴 작업인지 알 수 없기 때문에 일단 짧은 작업이라고 가정하여 높은 우선순위를 부여합니다. 진짜 짧은 작업이면 빨리 실행되고 바로 종료할 것입니다. 짧은 작업이 아니라면 천천히 아래 큐로 이동하게 되고 스스로 긴 배치형 작업이라는 것을 증명하게 됩니다. 이러한 방식으로 MLFQ는 SJF를 근사할 수 있습니다.

### 예 3: 입출력 작업에 대해서는 어떻게?

다음으로 입출력 작업을 수행하는 예를 살펴봅니다. 규칙 4b가 말하는 것처럼, 프로세스가 타임 슬라이스를 소진하기 전에 프로세서를 양도하면 같은 우선순위를 유지하게 합니다. 이 규칙의 의도는 대화형 작업이 키보드나 마우스로부터 사용자 입력을 대기하며 자주 입출력을 수행하면 타임 슬라이스가 종료되기 전에 CPU를 양도하게 될 것입니다. 그런 경우 동일한 우선순위를 유지하게 하는 것입니다.

![11 4](https://github.com/chu-aie/os-2024/assets/162019986/536008c5-cd3b-456d-987c-1a2a949e064d)

그림 11.4는 이 규칙이 동작하는 예를 보이고 있습니다. B(회색)는 대화형 작업으로서 입출력을 수행하기 전에 1 msec 동안만 실행됩니다. A(검정색)는 긴 배치형 작업으로 B 와 CPU를 사용하기 위하여 경쟁합니다. B는 CPU를 계속해서 양도하기 때문에 MLFQ 방식은 B를 가장 높은 우선순위로 유지합니다. B가 대화형 작업이라면 MLFQ는 대화형 작업을 빨리 실행시킨다는 목표에 더 근접하게 됩니다.

### 현재 MLFQ의 문제점

현재 MLFQ는 단순합니다. CPU를 긴 작업들과 짧은 작업들 사이에 잘 공유하고, 입출력-중점 대화형 작업을 빨리 실행시키기 때문에 잘 동작하는 것처럼 보입니다. 이 방식은 심각한 결점을 가집니다.

1. 기아 상태(starvation)가 발생할 수 있습니다. 시스템에 너무 많은 대화형 작업이 존재하면 그들이 모든 CPU 시간을 소모하게 될 것이고 따라서 긴 실행 시간 작업은 CPU 시간을 할당 받지 못할 것입니다. 이러한 시나리오에서도 긴 실행 시간 작업들도 진행이 되도록 만들면 좋을 것입니다.

![11 5](https://github.com/chu-aie/os-2024/assets/162019986/5a4b708d-83c4-418a-8c13-fb60fe55c33f)

2. 똑똑한 사용자라면 스케줄러를 자신에게 유리하게 동작하도록 프로그램을 다시 작성할 수 있습니다. 스케줄러를 자신에게 유리하게 동작 시킨다는 것은 일반적으로 스케줄러를 속여서 지정된 몫보다 더 많은 시간을 할당하도록 하게 만드는 것을 가리킵니다. 지금까지 논의한 알고리즘은 다음과 같은 공격에 취약합니다. 타임 슬라이스가 끝나기 전에 아무 파일을 대상으로 입출력 요청을 내려 CPU를 양도합니다. 그렇게 하면 같은 큐에 머무를 수 있고 따라서 더 높은 퍼센트의 CPU 시간을 얻게 됩니다. 제대로 된다면, 예를 들어 타임 슬라이스의 99%를 실행하고 CPU를 양도하게 되면 CPU를 거의 독점할 수 있습니다.

마지막으로 프로그램은 시간 흐름에 따라 특성이 변할 수 있습니다. CPU 위주 작업이 대화형 작업으로 바뀔 수 있습니다. 현재 구현 방식으로는 그런 작업은 운이 없게도 다른 대화형 작업들과 같은 대우를 받을 수 없습니다.

## 시도 2: 우선순위의 상향 조정

규칙을 보완하여 기아 문제를 방지할 수 있는지 살펴봅시다. CPU 위주 작업이 조금이라도 진행하는 것을 보장하기 위해서 무엇을 할 수 있는가?

간단한 아이디어는 주기적으로 모든 작업의 우선순위를 상향 조정(boost) 하는 것입니다. 목적을 달성하기 위해 여러 방법이 존재하지만 간단한 방법을 사용하기로 합시다. 모두 최상위 큐로 보내는 것입니다. 새로운 규칙은 다음과 같습니다.

- 규칙 5: 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킵니다.

새 규칙은 두 가지 문제를 한 번에 해결합니다.

1. 프로세스는 굶지 않는다는 것을 보장받습니다. 최상위 큐에 존재하는 동안 작업은 다른 높은 우선 순위 작업들과 라운드 로빈 방식으로 CPU를 공유하게 되고 서비스를 받게 됩니다.
2. CPU 위주의 작업이 대화형 작업으로 특성이 변할 경우 우선순위 상향을 통해 스케줄러가 변경된 특성에 적합한 스케줄링 방법을 적용합니다.

예를 들어 긴 실행 시간을 가진 작업이 두 개의 대화형 작업과 CPU를 두고 경쟁할 때의 행동을 보여주는 시나리오입니다. 이 두 개의 그래프가 그림 11.5에 나와 있습니다. 왼쪽 그래프는 우선 순위 상향이 없는 경우를 보이고 있습니다. 긴 실행 시간 작업은 두 개의 짧은 작업이 도착한 이후에는 굶게 됩니다. 오른쪽 그래프는 50 msec 마다 우선 순위 상향이 일어납니다. 너무 짧은 시간이지만 예를 위해 사용되었습니다. 긴 실행 시간 작업도 꾸준히 진행된다는 것을 보장할 수 있으며, 50 msec 마다 상향되고 따라서 주기적으로 실행됩니다.

물론 S값의 결정이 필요합니다. S를 얼마로 해야 하는가? 존경받는 시스템 연구자인 John Ousterhout [Ous11]는 이러한 종류의 값을 부두 상수(voo-doo constants)라고 불렀습니다. 이러한 값을 정확하게 결정하기 위해서는 흑마술이 필요한 것처럼 보이기 때문입니다. 불행하게도 S는 그러한 종류의 변수입니다. 너무 크면 긴 실행 시간을 가진 작업은 굶을 수 있으며 너무 작으면 대화형 작업이 적절한 양의 CPU 시간을 사용할 수 없게 됩니다.

## 시도 3: 더 나은 시간 측정

해결해야 할 문제가 하나 더 있습니다. 스케줄러를 자신에게 유리하게 동작시키는 것을 어떻게 막을 수 있는가? 이러한 일을 가능하게 만든 주범은 규칙 4a와 4b입니다. 두 규칙은 작업이 타임 슬라이스가 끝나기 전에 CPU를 양보하여 우선 순위를 유지가 가능하게 합니다. 우리는 무엇을 해야 하는가?

여기서의 해결책은 MLFQ의 각 단계에서 CPU 총 사용 시간을 측정하는 것입니다. 스케줄러는 현재 단계에서 프로세스가 소진한 CPU 사용 시간을 저장합니다. 프로세스가 타임 슬라이스에 해당하는 시간을 모두 소진하면 다음 우선순위 큐로 강등됩니다. 타임 슬라이스를 한 번에 소진하든 짧게 여러 번 소진하든 상관없습니다. 규칙 4a와 4b를 합쳐 하나의 규칙으로 재정의합니다.

- 규칙 4: 주어진 단계에서 CPU를 몇 번 양도하였는지 상관없이 시간 할당량을 소진하면, 우선순위는 낮아집니다. (즉, 아래 단계의 큐로 이동합니다.)

![11 6](https://github.com/chu-aie/os-2024/assets/162019986/1ea7d57a-63fb-4d54-ae7a-52d84ea0d83b)

예를 살펴보도록 합시다. 그림 11.6은 워크로드가 스케줄러를 자신에게 유리하게 동작 시키려고 할 때 예전 규칙 4a와 4b일 때의 행동(왼쪽)과 새로운 조작 방지 규칙 4일 때의 행동 양식을 보이고 있습니다. 이런 자신에게 유리하도록 조작하는 데 대한 방지책이 없다면 프로세스는 타임 슬라이스가 끝나기 직전에 입출력 명령어를 내릴 수 있어서 CPU 시간을 독점할 수 있습니다. 방지책이 마련되면 프로세스의 입출력 행동과 무관하게 아래 단계 큐로 천천히 이동하게 되어 CPU를 자기 몫 이상으로 사용할 수 없게 됩니다.

## MLFQ 조정과 다른 쟁점들

MLFQ 스케줄링에는 여러 다른 쟁점들이 남아 있습니다. 필요한 변수들을 스케줄러가 어떻게 설정해야 하는지도 중요한 문제입니다. 예를 들어, 몇 개의 큐가 존재해야 하는가? 큐당 타임 슬라이스의 크기는 얼마로 해야 하는가? 기아를 피하고 변화된 행동을 반영하기 위하여 얼마나 자주 우선순위가 상향 조정되어야 하는가? 이러한 질문들에 대해 쉽게 대답할 수는 없습니다. 워크로드에 대해 충분히 경험하고 계속 조정해 나가면서 균형점을 찾아야 합니다.

![11 7](https://github.com/chu-aie/os-2024/assets/162019986/7d9ac186-117c-4c47-a061-0d03ba11ff55)

예를 들어, 대부분의 MLFQ 기법들은 큐 별로 타임 슬라이스를 변경할 수 있습니다. 우선순위가 높은 큐는 보통 짧은 타임 슬라이스가 주어집니다. 이 큐는 대화형 작업으로 구성되고, 결국 이 작업들을 빠르게 교체하는 것은 의미가 있습니다. (예: 10 msec 이하) 낮은 우선순위는 반대로 CPU-중심의 오래 실행되는 작업들을 포함합니다. 긴 타임 슬라이스(예: 수백 msec)가 적합합니다. 그림 11.7은 가장 높은 우선순위 큐는 10ms, 중간 큐는 20ms, 가장 낮은 큐는 40ms의 스케줄러에서 두 개의 작업이 실행되는 모양을 보입니다.

```{admonition} 팁: 부두 상수 피하기 (Ousterhout’s Law)
가능하다면 부두 상수를 피하는 것이 좋은 생각입니다. 하지만 보통 앞의 예처럼, 피할 수 없는 경우가 더 자주 일어납니다. 더 좋은 값을 찾고 그 방법도 쉽지는 않습니다. 흔한 결과: 디폴트 값으로 가득 찬 설정 파일. 설정 파일의 값들은 무언가 정확히 동작하지 않을 때 풍부한 경험의 관리자가 조정 가능합니다. 상상할 수 있듯이, 이 값은 대부분 있는 그대로 사용되며 디폴트 값이 현장에서 잘 작동하기를 바랄 뿐입니다. 이 팁은 오래된 운영체제 교수 John Ousterhout에 의해 알려졌기 때문에 Ousterhout’s Law라고 부릅니다.
```

Solaris의 MLFQ 구현, 시분할 스케줄링 클래스 또는 TS는 설정이 특히 쉽습니다. Solaris는 프로세스의 우선순위가 일생 동안 어떻게 변하는지, 타임 슬라이스의 길이는 얼마인지, 작업의 우선순위는 얼마나 자주 상향되는지를 결정하는 테이블을 제공합니다. 관리자는 이 테이블을 수정하여 스케줄러의 동작 방식을 바꿀 수 있습니다. 테이블의 기본 값은 큐의 개수는 60, 각 큐의 타임 슬라이스 크기는 가장 높은 우선순위 큐가 20msec에서 가장 낮은 우선순위 큐가 수백 msec까지 천천히 증가하고, 우선순위 상향 조정은 1초 정도마다 일어납니다.

다른 MLFQ 스케줄러는 테이블이나 이 장에서 설명한 정확한 규칙 같은 것은 사용하지 않습니다. 수학 공식을 사용하여 우선순위를 조정합니다. 예를 들어, FreeBSD의 스케줄러(버전 4.3)는 작업의 현재 우선순위를 계산하기 위하여 프로세스가 사용한 CPU 시간을 기초로 한 공식을 사용합니다. CPU 사용은 시간이 지남에 따라 감쇠 되어 이 장에서 설명한 방식과는 다른 방식으로 우선순위 상향을 제공합니다. 이와 같은 감쇠-사용(decay-usage) 알고리즘과 특성에 대한 훌륭한 개요는 Epema의 논문을 참조해야합니다.

마지막으로, 스케줄러들은 다른 여러 기능을 제공합니다. 예를 들어, 일부 스케줄러의 경우 가장 높은 우선순위를 운영체제 작업을 위해 예약해 둡니다. 일반적인 사용자 작업은 시스템 내에서 가장 높은 우선순위를 얻을 수 없습니다. 일부 시스템은 사용자가 우선순위를 정하는 데 도움을 줄 수 있도록 허용합니다. 예를 들어, 명령어 라인 도구인 nice를 사용하여 작업의 우선순위를 높이거나 낮출 수 있습니다. 작업의 실행 순서를 바꿀 수 있습니다. 자세한 사항은 man 페이지를 봐야합니다.

```{admonition} 팁: 가능하면 조언을 이용하시오
운영체제 시스템이 모든 프로세스에게 어떤 것이 최선인지 알 수는 없습니다. 사용자 또는 관리자가 힌트를 전달할 수 있는 인터페이스를 제공하는 것이 도움이 됩니다. 우리는 그러한 힌트(hint)를 조언(advice)이라고 부릅니다. 운영체제가 힌트를 반드시 고려할 필요는 없지만 더 나은 결정을 내리는 데 힌트가 도움이 될 수는 있기 때문입니다. 이러한 힌트는 스케줄러 (예, nice), 메모리 관리자 (예, madvise), 파일 시스템 (예, 제공 정보에 기초한 선반입과 캐싱 등을 포함한 운영체제의 여러 부분에서 유용합니다.
```

## MLFQ: 요약

우리는 멀티 레벨 피드백 큐로 알려진 스케줄링 방법을 기술하였습니다. 이제 왜 그런 이름으로 불리는지 이해했을 것입니다. 알고리즘은 멀티 레벨 큐를 가지고 있으며, 지정된 작업의 우선순위를 정하기 위하여 피드백을 사용합니다. 과거에 보여준 행동이 우선순위 지정의 지침이 됩니다. 작업이 시간이 지남에 따라 어떻게 행동하고 그에 맞게 어떻게 처리하는지에 대해 주의를 기울여야 합니다.

이 장 전체에 산재해 있는 정교한 MLFQ 규칙의 집합을 보기 쉽게 여기에 다시 적어 보겠습니다.

- 규칙 1: 우선순위 (A)> 우선순위 (B) 일 경우, A가 실행, B는 실행되지 않습니다.
- 규칙 2: 우선순위 (A) = 우선순위 (B), A와 B는 RR 방식으로 실행됩니다.
- 규칙 3: 작업이 시스템에 들어가면 최상위 큐에 배치됩니다.
- 규칙 4: 작업이 지정된 단계에서 CPU를 포기한 횟수와 상관없이 배정받은 시간을 소진하면, 작업의 우선순위는 감소합니다. (즉, 한 단계 아래 큐로 이동합니다.)
- 규칙 5: 일정 주기 S가 지난 후, 시스템의 모든 작업을 최상위 큐로 이동시킵니다.

MLFQ는 다음과 같은 측면에서 매우 흥미로운 스케줄러입니다. 작업의 특성에 대한 정보 없이, 작업의 실행을 관찰한 후 그에 따라 우선순위를 지정합니다. MLFQ는 반환 시간과 응답 시간을 모두 최적화합니다. 짧게 실행되는 대화형 작업에 대해서는 우수한 전반적인 성능을 제공합니다. (SJF/ STCF와 유사) 오래 실행되는 CPU-집중 워크로드에 대해서는 공정하게 실행하고 조금이라도 진행되도록 합니다. 이런 이유로 BSD Unix와 여기서 파생된 다양한 운영체제[Lef+89; Bac86], Solaris [McD06], Windows NT 및 이후 Windows 운영체제 [CS97]를 포함한 많은 시스템이 기본 스케줄러로 MLFQ를 사용합니다.
