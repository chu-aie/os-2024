# 메모리 관리 API

이 장에서는 Unix 시스템에서 메모리를 관리하기 위한 API(Application Programming Interface)에 대해 알아보겠습니다. 여기서 말하는 메모리란 프로세스의 사용자 주소 공간을 의미합니다. 우리가 해결하고자 하는 핵심 질문은 다음과 같습니다.

```{admonition} 핵심 질문
프로그램에서 메모리를 어떻게 할당하고 관리해야 할까?
```

Unix/C 프로그램에서 메모리를 효과적으로 사용하는 방법을 이해하는 것은 안정적이고 강력한 소프트웨어를 개발하는 데 있어 매우 중요합니다. 어떤 API가 제공되고, 어떤 실수를 피해야 하는지 살펴보도록 하겠습니다.

## 메모리 공간의 종류[^ParkEunSeongKR]

[^ParkEunSeongKR]: [박은성](https://github.com/ParkEunSeongKR)

C 프로그램이 실행될 때, 크게 두 가지 유형의 메모리 공간이 할당됩니다.

첫 번째는 '스택(stack)' 메모리입니다. 스택 메모리의 할당과 해제는 프로그래머를 대신하여 컴파일러가 자동으로 처리해줍니다. 그래서 때로는 '자동(automatic)' 메모리라고도 불립니다.

C에서 스택에 메모리를 할당하는 것은 매우 간단합니다. 예를 들어 `func()`라는 함수 내에서 `x`라는 이름의 정수 변수를 선언한다고 해 보죠.

```c
void func() {
    int x;  // 스택에 정수형 변수 선언
    // ...
}
```

컴파일러는 `func()`가 호출될 때 스택 프레임 내에 `x`를 위한 공간을 마련해 둡니다.

두 번째 유형은 '힙(heap)' 메모리입니다. 힙은 함수 호출이 끝난 후에도 유지되어야 하는 데이터를 저장하는 데 사용됩니다. 힙 메모리의 할당과 해제는 프로그래머가 직접 관리해야 합니다.

다음은 힙에 정수 포인터를 할당하는 예시 코드입니다.

```c
void func() {
    int *x = (int*) malloc(sizeof(int));
    // ...
}
```

이 코드에는 몇 가지 주목할 점이 있습니다.

먼저 한 줄 안에서 스택과 힙 할당이 동시에 일어납니다. 컴파일러는 `int *x` 선언을 보고 정수 포인터를 위한 공간을 스택에 마련합니다. 그리고 `malloc()` 함수 호출을 통해 정수 자체를 저장할 공간을 힙에서 동적으로 할당받습니다.

`malloc()`이 반환하는 것은 새로 할당된 공간의 주소값입니다. 성공 시에는 해당 주소를, 실패 시에는 `NULL`을 돌려주죠. 이 주소값은 스택의 `x` 변수에 저장되어 프로그램에서 사용됩니다.

이처럼 명시적으로 메모리를 관리해야 하고 다양한 용도로 사용되는 힙 메모리는 프로그래머에게나 시스템에게나 쉽지 않은 도전 과제입니다. 앞으로의 논의는 주로 힙 메모리 관리에 초점을 맞출 것입니다.

몇 가지 핵심 용어를 정리해 보겠습니다.

- API (Application Programming Interface)

  - 운영체제나 라이브러리가 제공하는 함수나 메서드의 집합을 말합니다. 프로그래머는 API를 통해 시스템 자원에 접근하고 제어할 수 있습니다.

- 스택 (Stack)

  - 함수 호출 시 할당되는 메모리 영역으로, 함수의 매개변수, 지역변수, 리턴 주소 등이 저장됩니다. LIFO(Last-In-First-Out) 구조를 가지며, 함수 호출이 완료되면 자동으로 해제됩니다.

- 힙 (Heap)

  - 프로그램이 실행 중에 동적으로 할당하고 해제할 수 있는 메모리 영역입니다. 프로그래머가 직접 메모리 생명주기를 관리해야 합니다. 힙은 스택과 달리 비연속적이고 임의 접근 가능한 메모리 블록들로 구성됩니다.

- `malloc()`
  - C 언어에서 힙 메모리를 동적 할당하기 위해 사용하는 함수입니다. 할당할 바이트 수를 인자로 받아, 성공 시 할당된 메모리의 주소를 `void*` 타입으로 반환합니다.

이제 실제로 어떤 API들이 있는지, 그리고 메모리 관리에서 주의해야 할 점은 무엇인지 하나씩 살펴보도록 하겠습니다.

## malloc() 함수

malloc() 호출은 매우 간단하다. 힙에 요청할 공간의 크기를 넘겨 주면, 성공했을 경우 새로 할당된 공간에 대한 포인터를 사용자에게 반환하고 실패했을 경우 NULL을 반환한다.

매뉴얼 페이지는 malloc을 사용하는 데 필요한 일을 보여 준다. 명령어 라인에 manmalloc이라고 입력하면 다음과 같은 내용을 볼 것이다.

```
#include <stdlib.h>
. . .
void *malloc(size_t size);
```

이 정보로부터 malloc을 사용하기 위해서 할 일은 헤더 파일 stdlib.h를 소스 코드에 포함시키는 것 뿐이라는 것을 알 수 있다

malloc()의 인자는 size_t 타입의 변수이고 이 변수는 필요 공간의 크기를 바이트 단위로 표시한 것이다.

이 malloc() 호출에서는 정확한 크기의 공간을 요청하기 위하여 sizeof() 연산자를 사용한다. C 언어에서 이 sizeof()는 통상 컴파일 시간 연산자이다. sizeof()는 숫자 (이 경우 double의 크기인 8)로 대체되어 malloc()에 전달된다. 이러한 이유로, sizeof()는 연산자로 간주되는 게 맞으며 함수 호출이 아니다

데이터 타입뿐 아니라 변수의 이름도 sizeof()의 인자로 전달할 수 있다. 그러나 원하는 결과를 얻지 못할 때도 있으므로 조심해야 한다. 예를 들어, 다음과 같은 코드를 살펴보자.

```
int *x = malloc(10 * sizeof(int));
printf(“%d\n ”, sizeof(x));
```

첫 번째 행에서, 정수형 원소 10개를 가지는 배열을 위한 공간을 선언하였다.

그러나 다음 줄에서 sizeof()를 사용하면 4(32비트 컴퓨터에서) 또는 8(64비트 컴퓨터에서) 값을 반환한다. 이 경우 sizeof()는 동적으로 할당받은 메모리의 크기가 얼마인지가 아니라, 정수를 가리키는 포인터의 크기가 얼마인지 물어본다고 생각하기 때문이다. 그러나 때때로 sizeof()는 기대한 대로 동작할 때도 있다.

```
int x[10];
printf(“%d\n ”, sizeof(x));
```

이 경우에는 변수 x에 40ၵ이트가 할당되ᨩ다는 것을 컴파일러가 알 수 있는 정적인 정보가 충분하다.

또 하나 조심해야 하는 경우는 문자열을 다룰 때이다. 문자열을 위한 공간을 선언할 때에는 다음과 같은 문장을 사용한다 : mallocc(strlen(s) + 1). 이 문장은 strlen() 함수를 사용하여 문자열의 길이를 얻어낸 뒤 문자열-끝을 나타내는 문자를 위한 공간을 확보하기 위해 1바이트를 더한다.

sizeof()의 사용은 여기서 문제를 일으킬 수 있다.

malloc()은 void 타입에 대한 포인터를 반환한다는 것을 알았을 것이다. 그렇게 하는 것은 주소만 넘겨주고 해당 주소 공간에 어떤 타입의 자료를 저장할 지는 프로그래머가 결정하게 하는 전형적인 C의 방식이다.

프로그래머는 타입 변환(type casting)을 이용하여 공간 활용을 결정한다. 위의 예에서 프로그래머는 malloc()이 반환한 데이터 타입을 double 형을 가리키는 포인터 타입으로 변환하였다.

malloc()의 결과에 타입을 명시함으로써, 프로그래머는 정확한 타입을 “확인”한 정도이며, 프로그램이 제대로 동작하는 데 있어서 캐스트가 반드시 필요한 것은 아니다.

## free() 함수

“메모리 할당”은 우리가 고민하고 있는 문제들 중 쉬운 쪽이다.

할당된 메모리를 언제, 어떻게 해제하고 더욱이 해제 여부를 확인하는 것이 더 어려운 문제이다. 더 이상 사용 되지 않는 힙 메모리를 해제하기 위해 프로그래머는 free()를 호출한다.

```
int *x = malloc(10 * sizeof(int));
. . .
free(x);
```

한 개의 인자, malloc()에 의해 반환된 포인터를 받는다. 할당된 영역의 크기는 전달되지 않는다. 할당된 메모리의 크기는 메모리 할당 라이브러리가 알고 있어야 한다.

## 운영체제의 지원 [^Jo-Sehyun]

[^Jo-Sehyun]: [조세현](https://github.com/Jo-Sehyun)

malloc()과 free() 함수는 표준 C 라이브러리 함수로, 메모리 할당과 해제를 담당한다. 이들 함수는 시스템 콜이 아니라 라이브러리 함수이며, malloc 라이브러리가 프로세스 가상 주소 공간 안의 공간을 관리하지만 라이브러리 자체는 시스템에게 더 많은 메모리를 요구하고 반환하는 시스템 콜을 기반으로 구축되는데 그런 시스템 콜 중 하나가 brk 시스템 콜이다.

brk 시스템 콜은 프로그램의 break 위치를 변경하여 힙의 크기를 증가 또는 감소시킨다. break는 힙의 끝을 나타내는데, brk 시스템 콜은 새로운 break 주소를 인자로 받아 이를 기준으로 힙의 크기를 조절한다. sbrk 함수는 brk와 비슷한 용도로 사용되지만, 증가량만을 인자로 받는다.

중요한 점은 직접적으로 brk나 sbrk를 호출해서는 안 된다는 것이다. 이들은 메모리 할당 라이브러리에 의해 내부적으로 사용되므로 직접적인 호출은 예측할 수 없는 결과를 초래할 수 있다. 반드시 malloc()과 free()를 사용하여 메모리를 할당하고 해제해야 한다.

또한, mmap() 함수를 사용하여 운영체제로부터 메모리를 얻을 수도 있다. mmap() 함수는 올바른 인자를 전달하면 프로그램에 특정 파일과 연결되지 않은 스왑 공간(swap space)에 연결된 anonymous 메모리 영역을 만들어준다. 이 메모리 영역은 힙과 유사하게 취급되며 관리된다. 이러한 방법은 특히 대용량 메모리 할당이 필요한 경우에 유용하다.

## 기타 함수들

메모리 할당과 관련하여 몇 가지 추가 함수들이 있다.

1. calloc()
   - calloc() 함수는 메모리를 할당하고 해당 영역을 0으로 초기화하여 반환한다.
   - 이 함수는 초기화하는 것을 잊어버리는 오류를 방지하기 위해 사용된다.
   - 예를 들어, 동적으로 할당된 배열을 초기화할 때 유용하다. 이 함수는 메모리를 할당하고 0으로 초기화된 영역을 반환한다.
   - 이는 "초기화되지 않은 읽기"에 관련된 문제를 방지하는 데 도움이 된다.
2. realloc()
   - realloc() 함수는 이미 할당된 메모리 공간에 대해 추가적인 공간이 필요할 때 사용된다.
   - 예를 들어, 배열의 크기를 늘리거나 줄일 때 사용된다.
   - 이 함수는 더 큰 새로운 영역을 확보하고 이전 영역의 내용을 새 영역으로 복사한 후, 새 영역에 대한 포인터를 반환한다.
   - 이를 통해 메모리를 재사용하고 효율적으로 관리할 수 있다.

## 요약

이 장에서는 C 프로그램에서 사용되는 두 가지 유형의 메모리 공간에 대해 설명했다.

1. 스택(Stack): 스택 메모리는 함수 호출 및 지역 변수와 같은 자동 메모리 할당에 사용된다. 프로그래머가 명시적으로 할당 및 반환할 필요 없이 컴파일러가 자동으로 관리한다. 예를 들어, 함수 내에서 변수를 선언할 때 스택에 메모리가 할당된다.

2. 힙(Heap): 힙 메모리는 프로그램이 실행되는 동안 동적으로 할당되며, 직접적인 관리가 필요하다. 모든 할당과 반환은 프로그래머가 명시적으로 처리해야 한다. 예를 들어, malloc() 함수를 사용하여 힙에서 메모리를 할당하고, free() 함수를 사용하여 할당된 메모리를 해제한다.

이 외에도 calloc() 함수는 메모리를 할당하고 0으로 초기화하여 반환하며, realloc() 함수는 이미 할당된 메모리 공간을 재할당하여 크기를 조정한다.

프로그램에서는 주로 스택과 힙 메모리를 조합하여 필요한 데이터를 관리하며, 각 메모리 유형은 서로 다른 목적과 동작 방식을 가지고 있다.
