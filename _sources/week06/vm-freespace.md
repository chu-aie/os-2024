# 빈 공간 관리

## 가정[^ParkEunSeongKR]

[^ParkEunSeongKR]: [박은성](https://github.com/ParkEunSeongKR)

이 논의의 대부분은 사용자 수준 메모리 할당 라이브러리에 존재하는 메모리 할당기의 발전 역사에 초점을 맞출 것이다.

malloc()과 free()에서 제공하는 것과 같은 기본 인터페이스를 가정한다. 구체적으로 void *malloc (size_t size)는 응용 프로그램이 요청한 바이트 수를 나타내는 변수 size를 받아들인다. 이 함수는 요청된 크기와 같거나 큰 영역을 가리키는, 타입이 없는는 또는 C 언어의 용어로 void 포인터를 반환한다. 대응되는 루틴 void free(void *ptr)는 포인터를 인자로 전달받고 해당 영역을 해제한다.

인터페이스의 의미에 주의하라. 공간을 해제할 때 사용자는 라이브러리에게 크기 정보를 전달하지 않는다. 라이브러리는 포인터만으로 해제하고자 하는 메모리 영역의 크기를 파악해야 한다. 크기를 알아내는 방법에 대해 나중에 논의할 것이다.

이 라이브러리가 관리하는 공간은 역사적으로 힙(heap)으로 불리며, 힙의 빈 공간을 관리하는 데는 일반적인 링크드리스트가 사용된다. 이 자료 구조는 영역 내의 모든 빈 청크에 대한 주소를 갖고 있다. 물론, 이 자료 구조는 반드시 리스트일 필요는 ᨧ고 빈 공간들을 표현할 수 있는 자료 구조면 충분하다

우리는 위에서 언급한 것처럼 외부 단편화 방지에 특히 중점을 두겠다. 물론, 내부 단편화 문제도 있을 수 있다. 할당기가 요청한 크기보다 더 큰 메모리 청크를 할당할 경우, 요청되지 않은 사용되지 않는 공간에 대해서는 할당 청크의 내부에서 낭비가 일어났기 때문에 내부 단편화라고 간주된다. 할당 공간 낭비의 또 다른 예라고 할 수 있다. 논의를 단순화하기 위하여, 그리고 두 유형 중 더 흥미롭기 때문에 외부 단편화에 초점을 맞출 것이다.

우리는 또한 클라이언트에게 할당된 메모리는 다른 위치로 재배치될 수 ᨧ다고 가정한다. 예를 들어, 프로그램이 malloc()을 호출하여 힙의 일부 영역에 대한 포인터를 받으면, 그 메모리 영역은 대응하는 free()를 통하여 반환될 때까지 프로그램이 소유하게 되고 라이브러리에 의해 다른 위치로 옮겨질 수 없다. 단편화 해결에 유용하게 사용되는 빈 공간의 압축은 이 경우에는 사용이 불가능하다. 운영체제가 세그멘트를 구현할 때는 단편화를 해결하기 위하여 압축을 사용할 수 있다. 이에 대해서는 세그멘테이션에 관해 논의한 장에서 언급하였다

## 저수준 기법들

## 기본 전략

## 다른 접근법

## 요약
