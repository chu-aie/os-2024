# 세그멘테이션 [^Jo-Sehyun]

[^Jo-Sehyun]: [조세현](https://github.com/Jo-Sehyun)

베이스와 바운드 레지스터를 사용하면 운영체제는 프로세스를 물리 메모리의 다른 부분으로 쉽게 재배치할 수 있습니다. 그러나 이러한 형태의 주소 공간에서 재미있는 사실은 스택과 힙 사이에 사용되지 않는 큰 공간이 존재한다는 것입니다. 이 공간은 주소 공간을 물리 메모리에 재배치할 때 물리 메모리를 차지하게 됩니다. 베이스와 바운드 레지스터 방식은 이러한 메모리 낭비가 심할 수 있으며, 또한, 주소 공간이 물리 메모리보다 큰 경우 실행이 어려워질 수 있습니다. 이러한 측면에서 볼 때, 베이스와 바운드 방식은 유연성이 부족한 것으로 여겨집니다.

> **핵심 질문: 대용량 주소 공간을 어떻게 지원하는가**
>
> 스택과 힙 사이에 잠재적으로 큰 빈 영역이 존재하는 주소 공간을 어떻게 지원할까요?
> 작은 주소 공간에서는 낭비는 그렇게 심각하지 않지만 크기가 4 GB인 32비트 주소 공간을 생각해보면 통상 프로그램은 단지 수 메가바이트만 사용함에도 불구하고 주소 공간 전체가 메모리에 탑재되어야 합니다.

## 세그멘테이션: 베이스/바운드(base/bound) 의 일반화

위 문제를 해결하기 위한 아이디어 중 하나가 바로 세그멘테이션(segmentation) 입니다.

세그멘테이션은 오랜 역사를 가진 메모리 관리 기법 중 하나로, 최소 1960년대 초까지 거슬러 올라갈 수 있습니다. 이 방법은 메모리의 효율적인 사용과 프로그램의 보다 유연한 배치를 가능하게 합니다.

세그멘테이션은 주소 공간을 논리적으로 분할하여 각각의 세그먼트에 대해 별도의 베이스(base)와 바운드(bound) 쌍을 할당하여 메모리 관리 장치(MMU)에 저장하는 방식입니다. 이러한 세그먼트는 특정 길이를 가지는 연속적인 주소 공간을 나타내며, 일반적으로 코드, 스택, 및 힙 등과 같이 프로그램이나 데이터의 논리적인 부분을 나타냅니다.

세그멘테이션을 사용하면 운영체제는 각 세그먼트를 메모리에 별도로 배치함으로써 프로그램이나 데이터를 물리 메모리의 다양한 위치에 할당할 수 있습니다. 또한 사용되지 않는 가상 주소 공간이 물리 메모리를 차지하는 것을 방지할 수 있습니다.

![19 1](https://github.com/chu-aie/os-2024/assets/162019986/987719c3-0cd3-44a2-ad6a-9432e4a3dbb7)

예를 들어, 그림 19.1의 주소 공간을 물리 메모리에 배치하려고 합니다. 각 세그먼트의 베이스와 바운드 쌍을 이용하여 세그먼트들을 독립적으로 물리 메모리에 배치할 수 있습니다.

![19 2](https://github.com/chu-aie/os-2024/assets/162019986/e80f1558-e888-42a5-bb46-7d0fa6baf8c7)

그림 19.2를 보면 64 KB의 물리 메모리에 3개의 세그먼트와 운영체제용으로 예약된 16 KB 영역이 존재합니다. 그림에서 볼 수 있듯이, 사용 중인 메모리에만 물리 공간이 할당됩니다. 이러한 구조는 사용되지 않은 영역이 많은 대형 주소 공간(드문드문 사용되는 주소 공간(sparse address space)이라고도 부름)을 수용할 수 있습니다.

세그먼트 지원을 위한 MMU 하드웨어 구조는 예상한 것과 같습니다. 이 예의 경우 3쌍의 베이스와 바운드 레지스터 집합이 필요합니다.

![19 3](https://github.com/chu-aie/os-2024/assets/162019986/c7c90c74-681b-47bb-9f41-0b317f7b32ef)

그림 19.3은 앞의 예에 해당하는 각 레지스터의 값을 보여줍니다. 각 바운드 레지스터는 세그먼트의 크기를 저장합니다. 그림에서 코드 세그먼트가 물리 주소 32 KB에 배치되고 크기는 2 KB이며, 힙 세그멘트가 34 KB에 배치되고 역시 크기는 2 KB라는 것을 알 수 있습니다.

> **세그먼트 폴트의 여담**
>
> 용어 Segment Fault는 세그먼트 사용 시스템에서 불법적인 주소 접근 시 발생합니다.
> 이 용어는 세그먼트에 대한 지원이 전혀 없는 컴퓨터에서도 여전히 사용되는데, 이 경우에는 코드의 오류 원인을 알 수 없습니다.

위 그림 19.1의 주소 공간을 사용하여 주소 변환을 살펴봅시다. 먼저, 가상 주소 100번지가 참조된다고 가정해봅시다. 이 주소는 코드 세그먼트에 속합니다. 참조가 발생하면, 하드웨어는 해당 세그먼트의 베이스 값에 가상 주소의 오프셋을 더합니다. 이 경우, 100을 더하여 물리 주소는 100 + 32 KB로 계산되어 32868이 됩니다. 그 후, 하드웨어는 이 주소가 범위 내에 있는지 확인하고 (100은 2 KB보다 작으므로), 범위 내에 있다면 물리 메모리 주소 32868을 읽습니다.

다음으로 가상 주소 4200번지를 힙에서 살펴보면, 힙의 베이스인 34 KB에 이를 더하면 물리 주소 39016을 얻게 됩니다. 그러나 이 주소는 올바른 물리 주소가 아닙니다. 먼저 힙 내에서의 오프셋, 즉 주소가 세그먼트의 시작으로부터 몇 번째 바이트인지를 확인해야 합니다. 힙은 가상 주소 4 KB(4096)에서 시작하기 때문에 오프셋은 4200 - 4096으로 계산되어 104가 됩니다. 이 오프셋(100)을 힙의 베이스 레지스터의 물리 주소(34 KB)에 더하면 원하는 결과인 34920을 얻을 수 있습니다.

그러나 만약 잘못된 주소인 힙의 마지막을 벗어난 7 KB와 같은 주소에 접근하려고 한다면 어떻게 될까요? 하드웨어는 이 주소가 범위를 벗어났다는 것을 감지하고 운영체제에 트랩을 발생시킵니다. 운영체제는 문제의 프로세스를 종료시킬 가능성이 큽니다. 이렇게 잘못된 주소 접근으로 인해 발생하는 문제를 C 프로그래머들이 많이 겪는 유명한 용어의 기원을 알 수 있습니다: 세그먼트 위반(segment violation) 또는 세그먼트 폴트(segment fault).

```{admonition}세그먼트 위반(segment violation) 또는 세그먼트 폴트(segment fault)의 기원
세그먼트 위반(segment violation) 또는 세그먼트 폴트(segment fault)는 프로그래밍에서 주소 접근 오류가 발생했을 때 나타나는 용어로 기원적으로는 주소 접근 오류가 발생했을 때, 해당 프로세스가 접근한 메모리 주소가 메모리 세그먼트의 범위를 벗어났을 때 발생한 것입니다. 이러한 오류는 프로그램이 메모리를 잘못 사용하거나 액세스하려고 할 때 발생합니다.

세그먼트 위반 또는 세그먼트 폴트가 나타나면, 보통 운영체제는 프로그램이 메모리를 잘못 사용하는 오류를 신속하게 감지하여 프로세스나 시스템의 안정성을 유지하기 위해 해당 프로세스를 중단하거나 종료시킵니다. 
```

## 세그멘트 종류의 파악

하드웨어는 주소 변환을 위해 세그먼트 레지스터를 사용합니다. 하드웨어는 가상 주소가 어느 세그먼트를 참조하는지, 그리고 그 세그먼트 안에서 오프셋은 얼마인지를 어떻게 알 수 있을까요?

한 가지 일반적인 접근 방법은 가상 주소의 최상위 몇 비트를 사용하여 주소 공간을 여러 세그먼트로 나누는 것입니다. 이 방법은 예를 들어 VAX/VMS 시스템에서 사용되었습니다. 위의 예에서는 3개의 세그먼트가 있으므로 주소 공간을 세그먼트로 나누기 위해서는 2비트가 필요합니다. 따라서 세그먼트를 표시하기 위해 가상 주소의 최상위 2비트를 사용하는 경우, 가상 주소의 형태는 다음과 같을 것입니다.

![segment(1)](https://github.com/chu-aie/os-2024/assets/162019986/aea2548e-a05e-4029-84bf-9002bf308b0d)

예를 들어, 최상위 2비트가 00이면 하드웨어는 가상 주소가 코드 세그먼트를 가리킨다는 것을 인식하고, 이에 따라 코드 세그먼트의 베이스와 바운드 쌍을 활용하여 주소를 정확한 물리 메모리 위치로 재배치합니다. 최상위 2비트가 01이면, 하드웨어는 주소가 힙 세그먼트를 가리킨다는 것을 인지하고, 힙의 베이스와 바운드를 사용하여 주소를 변환합니다. 이해를 돕기 위해 이전에 언급한 힙에 해당하는 가상 주소인 4200을 변환해 보면 가상 주소 4200에 대한 이진 표현은 다음과 같습니다.

![segment(2)](https://github.com/chu-aie/os-2024/assets/162019986/aad96d7c-48f4-4b56-b6e1-4011ea330a2a)

그림에서 볼 수 있듯이, 최상위 2비트 (01)는 하드웨어에게 참조하는 세그먼트의 종류를 알려줍니다. 그리고 하위 12비트는 해당 세그먼트 내의 오프셋을 나타냅니다. 예를 들어, 이진 형식으로 표현된 주소 0000 0110 1000은 16진수로는 0x068 또는 10진수로는 104입니다. 하드웨어는 세그먼트 레지스터를 이해하기 위해 처음 2비트를 사용하고, 그 다음 12비트를 세그먼트 오프셋으로 취합니다. 이 오프셋에 베이스 레지스터 값을 더하여 하드웨어는 최종적인 물리 주소를 계산합니다. 또한, 오프셋을 사용하면 바운드 검사도 쉽게 수행할 수 있습니다. 바운드를 넘어선 오프셋인지를 검사하기만 하면 됩니다. 그렇지 않으면 주소가 잘못된 것입니다. 만약 베이스와 바운드 쌍을 배열 형태로 저장한다면 (세그먼트당 하나의 항목), 원하는 물리 주소를 얻기 위해 다음과 같은 과정을 수행하게 됩니다.

![segment(3)](https://github.com/chu-aie/os-2024/assets/162019986/a4a11b0a-acd1-46b6-b71d-6199a2347543)

우리는 현재 예를 기준으로 위 코드에서 사용된 상수 값들을 설정할 수 있습니다. SEG_MASK는 0x3000, SEG_SHIFT는 12, 그리고 OFFSET_MASK는 0xFFF로 지정됩니다. 세그먼트 종류를 나타내는 데 최상위 2비트를 사용하고, 주소 공간에는 코드, 힙, 스택 세그먼트만 존재하기 때문에 지정 가능한 세그먼트 하나가 미사용으로 남게 됩니다. 즉, 전체 주소 공간의 1/4은 사용이 불가능합니다. 이 문제를 해결하기 위해 일부 시스템은 코드와 힙을 하나의 세그먼트에 저장하고 세그먼트 선택을 위해 1비트만 사용합니다.

특정 주소의 세그먼트를 하드웨어적으로 파악하는 다른 방법들도 있습니다. 묵시적(implicit) 접근 방식에서는 주소가 어떻게 형성되는지를 관찰하여 세그먼트를 결정합니다. 예를 들어, 주소가 프로그램 카운터에서 생성된다면 해당 주소는 코드 세그먼트 내에 있을 것입니다. 주소가 스택 또는 베이스 포인터에 의해 생성된다면 주소는 스택 세그먼트 내에 있을 것입니다. 다른 주소는 모두 힙에 위치하고 있어야 합니다.

## 스택

지금까지 주소 공간의 중요한 구성 요소 중 하나인 스택을 다루지 않았습니다. 앞의 그림 19.3에서는 스택이 물리 메모리의 28 KB에 배치되어 있지만 다른 세그먼트들과는 다르게 확장 방향이 반대라는 중요한 차이가 있습니다. 스택은 물리 메모리의 28 KB에서 시작하여 26 KB를 차지하며, 가상 주소에서는 16 KB에서 14 KB에 해당합니다. 이에 따라 다른 방식의 주소 변환이 필요합니다.

첫 번째, 간단한 하드웨어가 추가로 필요합니다. 베이스와 바운드 값뿐만 아니라 하드웨어는 세그먼트가 어느 방향으로 확장하는지도 알아야 합니다. 예를 들어, 하나의 비트를 사용하여 주소가 양의 방향으로 확장되는 경우에는 1로 설정하고, 음의 방향으로 확장되는 경우에는 0으로 설정할 수 있습니다. 이러한 사실을 반영하여 아래 그림 19.4는 하드웨어가 관리해야 하는 정보를 나타냅니다.

하드웨어는 세그먼트가 반대 방향으로 확장될 수 있다는 것을 알기 때문에, 이러한 가상 주소에 대해서는 다른 방식으로 변환합니다. 스택에 해당하는 가상 주소를 예로 들어 변환해 보겠습니다. 이 예에서 가상 주소 15 KB에 접근하려고 한다고 가정할 때, 이 주소는 물리 주소 27 KB에 매핑되어야 합니다. 이 가상 주소를 이진 형태로 변환하면 11 1100 0000 0000 (16진수 0x3C00)이 됩니다. 하드웨어는 상위 2비트 (11)를 사용하여 세그먼트를 지정합니다. 이를 고려하면 3 KB의 오프셋이 남습니다. 올바른 음수 오프셋을 얻기 위해 3 KB에서 세그먼트 최대 크기를 빼야 합니다. 이 예에서는 세그먼트의 최대 크기가 4 KB이므로 올바른 오프셋은 3 KB에서 4 KB를 뺀 -1 KB입니다. 이 음수 오프셋 (-1 KB)을 베이스 (28 KB)에 더하면 올바른 물리 주소 27 KB를 얻게 됩니다. 바운드 검사는 음수 오프셋의 절댓값이 세그먼트의 크기보다 작다는 것을 확인하여 계산할 수 있습니다.

![19,4](https://github.com/chu-aie/os-2024/assets/162019986/8bee0453-44e9-488d-a552-4f113a37a520)

## 공유 지원

## 소단위 대 대단위 세그멘테이션

## 운영체제의 지원

## 요약
