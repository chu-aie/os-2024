
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>락 &#8212; 운영체제 2024</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-examples.css?v=e236af4b" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.bundle.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-shadow.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-punk.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-noir.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-light.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-borderless.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/micromodal.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script src="../_static/tabs.js?v=3ee01567"></script>
    <script src="../_static/js/hoverxref.js"></script>
    <script src="../_static/js/tooltipster.bundle.min.js"></script>
    <script src="../_static/js/micromodal.min.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-BQJE5V9RK2"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-BQJE5V9RK2');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-BQJE5V9RK2');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"N": "\\mathbb{N}", "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'week11/threads-locks';</script>
    <link rel="icon" href="https://assets.entelecheia.ai/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="락 기반의 병행 자료 구조" href="threads-locks-usage.html" />
    <link rel="prev" title="Week 11 - 병행성 2" href="index.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>


  <div class="bd-header-announcement container-fluid bd-header-announcement">
    <div class="bd-header-announcement__content">5/15일(수) 수업의 보강은 5/16일(목) 14:00에 진행됩니다.</div>
  </div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">운영체제 2024</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Home
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Lecture Notes</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../week01/index.html">Week 1 - 아주 쉬운 세 가지 이야기</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week01/intro.html">운영체제 개요</a></li>
<li class="toctree-l2"><a class="reference external" href="https://learn.microsoft.com/ko-kr/windows/wsl/install">WSL 설치방법</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week02/index.html">Week 2 - 가상화의 세계</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week02/cpu-intro.html">프로세스의 개념</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/cpu-api.html">프로세스 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/cpu-mechanisms.html">제한적 직접 실행 원리</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/shells.html">리눅스 셸 (Linux Shells)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/lab.html">Lab: Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/tip.html">Tip: 리눅스 프로세스 관리 명령어</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/hw-wk02.html">Homework: 프로세스</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week03/index.html">Week 3 - 스케줄링 1</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week03/cpu-scheduling.html">스케줄링: 개요</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week03/lab.html">Lab: 프로세스 생성과 실행 기초</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week03/wsl-setup.html">WSL에서 Ubuntu 환경구축 및 GitHub 설정하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week03/hw-wk03.html">Homework: 스케줄링</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week04/index.html">Week 4 - 스케줄링 2</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week04/mlfq.html">스케줄링: 멀티 레벨 피드백 큐</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/lottery.html">스케줄링: 비례 배분</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/lab-sched.html">Lab: 스케줄링 알고리즘 시뮬레이터</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/lab-lottery.html">Lab: Lottery 스케줄링 알고리즘 구현</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/hw-wk04.html">Homework: 비례 배분</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week05/index.html">Week 5 - 메모리 가상화 1</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week05/vm-intro.html">주소 공간의 개념</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week05/vm-api.html">메모리 관리 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week05/lab.html">Lab: 메모리 구조 탐색하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week05/tip-linux-cmd.html">Tip: Linux 기본 명령어</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week06/index.html">Week 6 - 메모리 가상화 2</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week06/vm-mechanism.html">주소 변환의 원리</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week06/vm-segmentation.html">세그멘테이션 </a></li>
<li class="toctree-l2"><a class="reference internal" href="../week06/lab.html">Lab: 주소 변환 시뮬레이션</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week06/hw-wk06.html">Homework: 주소 변환의 원리</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week07/index.html">Week 7 - 메모리 가상화 3</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week07/vm-freespace.html">빈 공간 관리</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week07/hw-wk07.html">Homework: 빈 공간 관리</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week09/index.html">Week 9 - 메모리 가상화 4</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week09/vm-paging.html">페이징: 개요</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week09/vm-tlbs.html">페이징: 더 빠른 변환 (TLB)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week09/vm-swap.html">물리 메모리 크기의 극복: 메커니즘</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week10/index.html">Week 10 - 병행성에 관한 대화</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week10/threads-intro.html">병행성: 개요</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week10/threads-api.html">쓰레드 API</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">Week 11 - 병행성 2</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">락 </a></li>
<li class="toctree-l2"><a class="reference internal" href="threads-locks-usage.html">락 기반의 병행 자료 구조</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week12/index.html">Week 12 - 병행성 2</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week12/threads-cv.html">컨디션 변수</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week12/threads-sema.html">세마포어</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Projects</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../projects/index.html">OS 프로젝트</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../projects/202121006/index.html">reverse 프로젝트</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-13"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk02.html">Week 2 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk03.html">Week 3 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk04.html">Week 4 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk06.html">Week 6 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk07.html">Week 7 Homework</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../projects/202121010/index.html">Key-Value store project by ypilseong</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-14"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121010/homework.html">Homework</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../projects/202221014/index.html">프로젝트: Key-Value Store 구현</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-15"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../projects/202221014/hw-wk02.html">Week 2 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202221014/hw-wk03.html">Week 3 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202221014/hw-wk04.html">Week 4 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202221014/hw-wk06.html">Week 6 Homework</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../projects/202321007/index.html">리버스 프로젝트 개요</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projects/202321010/index.html">reverse 프로젝트</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../projects/202321017/index.html">grep 프로젝트</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-16"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../projects/202321017/hw-wk02.html">Week 2 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202321017/hw-wk03.html">Week 3 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202321017/hw-wk04.html">Week 4 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202321017/hw-wk06.html">Week 6 Homework</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../projects/contents/index.html">프로젝트 과제 목록</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-17"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../projects/contents/utilities.html">유닉스 유틸리티 프로젝트</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projects/contents/reverse.html"><code class="docutils literal notranslate"><span class="pre">reverse</span></code> 프로젝트</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projects/contents/kv.html"><code class="docutils literal notranslate"><span class="pre">kv</span></code> 프로젝트: 간단한 키-값 저장소</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../projects/lab-tutorial.html">Lab 튜토리얼</a></li>
<li class="toctree-l1"><a class="reference internal" href="../projects/tester.html">프로젝트 테스터</a></li>
<li class="toctree-l1"><a class="reference internal" href="../projects/setup.html">프로젝트 환경설정</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../references/ostep/index.html">OSTEP (Korean Version)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/ostep-code/index.html">ostep-code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/ostep-homework/index.html">Homeworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/ostep-projects/index.html">Projects</a></li>
<li class="toctree-l1"><a class="reference external" href="https://kuleuven-diepenbeek.github.io/osc-course/">Operating Systems and C</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../syllabus/index.html">수업계획서</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">만든 사람들</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference external" href="https://halla.ai">인공지능학과</a></li>
<li class="toctree-l1"><a class="reference external" href="https://os2024.halla.ai">운영체제 2024</a></li>
<li class="toctree-l1"><a class="reference external" href="https://mlops2024.halla.ai">머신러닝시스템 2024</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cobots2024.halla.ai">협동로봇활용 2024</a></li>
<li class="toctree-l1"><a class="reference external" href="https://aibasics.halla.ai">AI 세상 속으로</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/chu-aie/os-2024" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/chu-aie/os-2024/edit/main/src/os2024/book/week11/threads-locks.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/chu-aie/os-2024/issues/new?title=Issue%20on%20page%20%2Fweek11/threads-locks.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/week11/threads-locks.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>락 </h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">락: 기본 개념</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pthread">Pthread 락</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">세밀한 락과 거친 락 전략</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">락 구현</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">락의 평가</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">인터럽트 제어</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#test-and-set-atomic-exchange">Test-And-Set (Atomic Exchange)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">정확성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">성능</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">진짜 돌아가는 스핀 락의 구현</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">스핀 락 평가</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#compare-and-swap">Compare-And-Swap</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fetch-and-add">Fetch-And-Add</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">요약: 과도한 스핀</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>락 <a class="footnote-reference brackets" href="#ypilseong" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a><a class="headerlink" href="#id2" title="Link to this heading">#</a></h1>
<p>Lock은 코드의 특정 영역을 감싸서 한 순간에 오로지 한 스레드만 이 영역에 접근할 수 있도록 해주는 것, 즉 Mutual Exclusion을 위해 존재합니다.
이 Lock이 없으면 Multi thread program이 제대로 예상한대로 작동하지 않을 가능성이 높습니다.</p>
<section id="id3">
<h2>락: 기본 개념<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="nv">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>balance<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="p">;</span>
</pre></div>
</div>
<p>다음과 같은 임계 영역이 있다고 하면 락으로 임계 영역을 다음과 같이 감쌌습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>lock_t<span class="w"> </span>mutex<span class="p">;</span><span class="w"> </span>//<span class="w"> </span>전역<span class="w"> </span>변수로<span class="w"> </span>선언된<span class="w"> </span>락
...
lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span>
<span class="nv">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>balance<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="p">;</span>
unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>락은 하나의 변수이므로, 락을 사용하기 위해 먼저 선언해야 합니다. 이 락 변수는 사용 가능 상태, 즉 어느 쓰레드도 락을 가지고 있지 않거나, 사용 중, 즉 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태입니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">lock()</span></code>과 <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>의 의미는 간단합니다. <code class="docutils literal notranslate"><span class="pre">lock()</span></code>을 호출하여 락 획득을 시도한다. 만약 어떤 쓰레드도 락을 가지고 있지 않다면 그 쓰레드는 락을 획득하여 임계 영역으로 진입합니다. 이렇게 진입한 쓰레드를 <em>락 소유자 (owner)</em> 라고 부른다. 만약 다른 쓰레드가 <code class="docutils literal notranslate"><span class="pre">lock()</span></code>을 호출한다면, 사용 중인 동안에는 <code class="docutils literal notranslate"><span class="pre">lock()</span></code> 함수가 리턴하지 않습니다.</p>
<p>락 소유자가 <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>을 호출한다면 락은 이제 다시 사용 가능한 상태가 됩니다. 어떤 쓰레드도 이 락을 대기하고 있지 않다면 (어떤 쓰레드도 <code class="docutils literal notranslate"><span class="pre">lock()</span></code>을 호출하여 멈춰 있던 상태가 아니라면) 락의 상태는 사용 가능으로 유지됩니다.</p>
<p>락은 프로그래머에게 스케줄링에 대한 최소한의 제어권을 제공합니다. 쓰레드에 대한 제어권을 일부 받을 수 있습니다. 이를 통해 프로그래머는 그 코드 내에서 하나의 쓰레드만 동작하도록 보장합니다. 혼란스런 실행 순서에 어느 정도 질서를 부여할 수 있는 것입니다.</p>
</section>
<section id="pthread">
<h2>Pthread 락<a class="headerlink" href="#pthread" title="Link to this heading">#</a></h2>
<p>쓰레드 간 <em>상호 배제 (mutual exclusion)</em> 기능을 제공하기 때문에 POSIX 라이브러리는 락을 <em>mutex</em> 라고 부릅니다. 상호 배제는 한 쓰레드가 임계 영역 내에 있다면, 이 쓰레드의 동작이 끝날 때까지 다른 쓰레드가 임계 영역에 들어올 수 없도록 제한한다고 해서 붙여진 이름입니다.</p>
<p>래퍼를 사용하여 락과 언락시에 에러를 확인하도록 합니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pthread_mutex_t<span class="w"> </span><span class="nv">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>PTHREAD_MUTEX_INITIALIZER<span class="p">;</span>

Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>lock<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>pthread_mutex_lock<span class="o">()</span>을<span class="w"> </span>위한<span class="w"> </span>래퍼.
<span class="nv">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>balance<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="p">;</span>
Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>lock<span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>POSIX 방식은 변수명을 지정하여 락과 언락 함수에 전달합니다. 다른 변수를 보호하기 위해 다른 락을 사용할수도 있기 때문입니다. 이를 통해 여러가지 방식으로 락을 구현할 수 있습니다.</p>
<section id="id4">
<h3>세밀한 락과 거친 락 전략<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>거친 락 (Coarse-Grained Locking)</p>
<ol class="arabic simple">
<li><p>하나의 락이 큰 임계 영역을 제어함.</p></li>
<li><p>쉽게 구현할 수 있지만, 병렬성이 제한됨.</p></li>
</ol>
</li>
<li><p>세밀한 락 (Fine-Grained Locking)</p>
<ol class="arabic simple">
<li><p>여러 락이 서로 다른 데이터나 자료구조를 보호함.</p></li>
<li><p>한 번에 여러 쓰레드가 서로 다른 락으로 보호된 코드 내에 진입 가능.</p></li>
<li><p>병렬성은 향상되지만, 데드락 등의 복잡한 이슈에 대처해야 함.</p></li>
</ol>
</li>
</ul>
</section>
</section>
<section id="id5">
<h2>락 구현<a class="headerlink" href="#id5" title="Link to this heading">#</a></h2>
</section>
<section id="id6">
<h2>락의 평가<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>상호 배제 (mutual exclusion)</p>
<ol class="arabic simple">
<li><p>가장 기본 역할.</p></li>
<li><p>임계 영역 내로 다수의 쓰레드가 진입하는 것을 막을 수 있는지 검사해야 함.</p></li>
</ol>
</li>
<li><p>공정성 (fairness)</p>
<ol class="arabic simple">
<li><p>여러 쓰레드들이 락을 번갈아가면서 획득할 수 있어야 함.</p></li>
<li><p>락을 전혀 얻지 못해 굶주리는 경우가 발생하면 안 됨.</p></li>
</ol>
</li>
<li><p>성능 (performance)</p>
<ol class="arabic simple">
<li><p>락 사용에 대한 시간적 오버헤드를 평가해야 한다.</p></li>
<li><p>하나의 쓰레드가 실행 중에 락을 획득하고 해제하는 과정에서 발생하는 부하가 얼마나 되는가?</p></li>
</ol>
</li>
</ul>
</section>
<section id="id7">
<h2>인터럽트 제어<a class="headerlink" href="#id7" title="Link to this heading">#</a></h2>
<p>초창기 단일 프로세서 시스템에서는 상호 배제 지원을 위해 임계 영역 내에서 인터럽트를 비활성화 하는 방법을 사용했습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>void<span class="w"> </span>lock<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>DisableInterrupts<span class="o">()</span><span class="p">;</span>
<span class="o">}</span>
void<span class="w"> </span>unlock<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>EnableInterrupts<span class="o">()</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>이 방법의 장점은 단순하다는 것이고, 단점은 많습니다.</p>
<ol class="arabic simple">
<li><p>먼저, 이 요청을 하는 쓰레드가 인터럽트를 활성화/비활성화 하는 커널 모드 특권 연산을 실행할 수 있도록 허가해야 합니다. 만약 어떤 프로그램이 시작과 동시에<code class="docutils literal notranslate"><span class="pre">lock()</span></code>을 호출하고 무한 반복문에 들어간다면, 운영체제는 시스템의 제어권을 다시 얻을 수 없습니다.</p></li>
<li><p>또, 멀티프로세서에서는 적용을 할 수 없습니다. 여러 쓰레드가 여러 CPU에서 실행 중이라면, 각 쓰레드가 동일한 임계 영역에 진입하려고 할 수 있습니다. 이 떄 인터럽트를 비활성화하는 것은 다른 프로세서에서 실행중인 프로그램에는 전혀 영향을 주지 않습니다. 즉, 임계 영역에 진입하는 것을 막을 수 없습니다.</p></li>
<li><p>장시간 인터럽트를 중지시키는 것은 중요한 인터럽트 시점을 놓치게 할 수 있습니다. CPU가 저장 장치에서 읽기 요청을 마친 사실을 모르고 지나갔다고 해보자. 운영체제는 읽기 결과를 기다리는 프로세스를 깨울 수 없을 것입니다.</p></li>
<li><p>마지막으로, 비효율적입니다. 일반적인 명령어에 비해 인터럽트를 비활성화시키는 코드들은 최신 CPU에서는 느리게 실행됩니다.</p></li>
</ol>
<p>따라서, 인터럽트 비활성화는 제한된 범위에서만 사용되어야 합니다. 예를 들어, 운영체제가 내부 자료 구조에 atomic 연산을 하기 위해 등</p>
</section>
<section id="test-and-set-atomic-exchange">
<h2>Test-And-Set (Atomic Exchange)<a class="headerlink" href="#test-and-set-atomic-exchange" title="Link to this heading">#</a></h2>
<p>멀티 프로세서 시스템에서는 인터럽트를 중지시키는 것이 의미가 없기 때문에 시스템 설계자들은 락 지원을 위한 하드웨어를 설계하기 시작했습니다. 오늘날에는 모든 시스템이 이러한 지원 기능을 가지고 있습니다.</p>
<p>하드웨어 기법 중 가장 기본은 <em>Test-And-Set</em> 명령어 또는 <em>원자적 교체 (atomic exchange)</em> 라고 불리는 기법입니다. 이를 이해하기 위해 간단한 플래그 변수로 락을 구현.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>typedef<span class="w"> </span>struct<span class="w"> </span>__lock_t<span class="w"> </span><span class="o">{</span><span class="w"> </span>int<span class="w"> </span>flag<span class="p">;</span><span class="w"> </span><span class="o">}</span><span class="w"> </span>lock_t<span class="p">;</span>

void<span class="w"> </span>init<span class="o">(</span>lock_t<span class="w"> </span>*mutex<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>//<span class="w"> </span><span class="m">0</span>:<span class="w"> </span>락<span class="w"> </span>사용<span class="w"> </span>가능
<span class="w">	</span>//<span class="w"> </span><span class="m">1</span>:<span class="w"> </span>락<span class="w"> </span>사용<span class="w"> </span>중
<span class="w">	</span>mutex−&gt;flag<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>lock<span class="o">(</span>lock_t<span class="w"> </span>*mutex<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="o">(</span>mutex−&gt;flag<span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span>//<span class="w"> </span>flag<span class="w"> </span>변수를<span class="w"> </span>검사<span class="w"> </span><span class="o">(</span><span class="nb">test</span><span class="o">)</span><span class="w"> </span>한다
<span class="w">	</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>spin−wait<span class="w"> </span><span class="o">(</span><span class="k">do</span><span class="w"> </span>nothing<span class="o">)</span>
<span class="w">	</span>mutex−&gt;flag<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>이제<span class="w"> </span>설정<span class="w"> </span><span class="o">(</span><span class="nb">set</span><span class="o">)</span><span class="w"> </span>한다
<span class="o">}</span>

void<span class="w"> </span>unlock<span class="o">(</span>lock_t<span class="w"> </span>*mutex<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>mutex−&gt;flag<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>간단한 변수를 사용해 쓰레드가 락을 획득했는지 나타냅니다. 임계 영역에 진입하는 첫 쓰레드가 <code class="docutils literal notranslate"><span class="pre">lock()</span></code>을 호출하여 플래그가 1인지 검사(test) 하고 플래그의 값을 1로 설정(set) 하여 이 쓰레드가 락을 보유(hold) 하고 있다고 표시합니다. 임계 영역에서 나오면 쓰레드가 <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>을 호출하여 플래그 값을 초기화하고, 락을 더 이상 보유하고 있지 않다고 표시합니다.</p>
<p>만약 첫 번째 쓰레드가 임계 영역 내에 있을 때 다른 쓰레드가 <code class="docutils literal notranslate"><span class="pre">lock()</span></code>을 호출하면 그 쓰레드는 <code class="docutils literal notranslate"><span class="pre">while</span></code>문으로 <em>spin-wait</em>을 하며 처음 쓰레드가 <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>을 호출하여 플래그를 초기화하기를 기다힙니다. 처음 쓰레드가 플래그를 초기화하면 대기하던 쓰레드는 <code class="docutils literal notranslate"><span class="pre">while</span></code> 문에서 빠져나와 플래그를 1로 설정하고 임계 영역 내로 진입합니다.</p>
<p>이 코드에는 두 가지 문제가 있습니다.</p>
<section id="id8">
<h3>정확성<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p><img alt="lock_ac" src="../_images/lock_ac.jpeg" /></p>
<p>시작할 때 <code class="docutils literal notranslate"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">0</span></code>이라 합시다. 쓰레드 1이 <code class="docutils literal notranslate"><span class="pre">flag</span> <span class="pre">=</span> <span class="pre">1</span></code>을 실행하기 직전에 인터럽트가 일어난다면? 두 쓰레드 모두 플래그를 1로 설정하도록 하는 인터럽트 타이밍이 존재합니다. 두 쓰레드 모두 임계 영역에 진입하게 됩니다. 잘못 만들었습니다.</p>
</section>
<section id="id9">
<h3>성능<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<p>spin wait을 통해 플래그의 값을 무한히 검사하는데, 이는 성능상 좋지 못합니다. 특히 단일 프로세서에서. 락을 소유한 쓰레드조차 실행하기 힘들도록 합니다.</p>
</section>
</section>
<section id="id10">
<h2>진짜 돌아가는 스핀 락의 구현<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>앞서 다룬 예제는 하드웨어 지원 없이는 동작이 불가능했습니다. 다행히도 어떤 시스템은 이 개념에 근간한 락 구현을 위한 어셈블리 명령어를 제공합니다. SPARC에서는 <code class="docutils literal notranslate"><span class="pre">ldstub</span></code>, x86에서는 원자적 교체 명령어인 <code class="docutils literal notranslate"><span class="pre">xchg</span></code>이다. 기본적으로 동일한 일을 수행합니다. 일반적으로 Test-And-Set 이라고 불립니다. <code class="docutils literal notranslate"><span class="pre">TestAndSet</span></code> 동작을 정의해보자.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>int<span class="w"> </span>TestAndSet<span class="o">(</span>int<span class="w"> </span>*old_ptr,<span class="w"> </span>int<span class="w"> </span>new<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span><span class="nv">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>*old_ptr<span class="p">;</span><span class="w"> </span>//<span class="w"> </span>old_ptr의<span class="w"> </span>이전<span class="w"> </span>값을<span class="w"> </span>가져옴
<span class="w">	</span>*old_ptr<span class="w"> </span><span class="o">=</span><span class="w"> </span>new<span class="p">;</span><span class="w"> </span>//<span class="w"> </span>old_ptr<span class="w"> </span>에<span class="w"> </span>new<span class="w"> </span>값을<span class="w"> </span>저장함
<span class="w">	</span><span class="k">return</span><span class="w"> </span>old<span class="p">;</span><span class="w"> </span>//<span class="w"> </span>old의<span class="w"> </span>값을<span class="w"> </span>반환함
<span class="o">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TestAndSet</span></code> 명령어가 하는 동작은 다음과 같다. <code class="docutils literal notranslate"><span class="pre">ptr</span></code>이 가리키고 있던 예전의 값을 반환하고, 동시에 <code class="docutils literal notranslate"><span class="pre">new</span></code> 값을 <code class="docutils literal notranslate"><span class="pre">ptr</span></code>에 저장합니다. 여기서의 핵심은 이 동작들이 원자적으로 수행된다는 것입니다. 이전 값을 검사 (test -&gt; 반환되는 값) 하는 동시에 메모리에 새로운 값을 설정 (set) 합니다.</p>
<p>이 명령어만으로 간단한 spin lock을 만들 수 있습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>typedef<span class="w"> </span>struct<span class="w"> </span>__lock_t<span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>flag<span class="p">;</span>
<span class="o">}</span><span class="w"> </span>lock_t<span class="p">;</span>

void<span class="w"> </span>init<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>//<span class="w"> </span>0은<span class="w"> </span>락이<span class="w"> </span>획득<span class="w"> </span>가능한<span class="w"> </span>상태
<span class="w">	</span>//<span class="w"> </span>1은<span class="w"> </span>락을<span class="w"> </span>획득했음
<span class="w">	</span>lock−&gt;flag<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>lock<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="o">(</span>TestAndSet<span class="o">(</span><span class="p">&amp;</span>lock−&gt;flag,<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="o">)</span>
<span class="w">	</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>spin
<span class="o">}</span>

void<span class="w"> </span>unlock<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>lock−&gt;flag<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>처음 쓰레드가 <code class="docutils literal notranslate"><span class="pre">lock()</span></code>을 호출하고, 다른 어떤 쓰레드도 현재 락을 보유하고 있지 않다고 하자. 그럼 현재 <code class="docutils literal notranslate"><span class="pre">flag</span></code>의 값은 0입니다. <code class="docutils literal notranslate"><span class="pre">TestAndSet(flag,</span> <span class="pre">1)</span></code>을 호출하면 반환 값은 0 이라 <code class="docutils literal notranslate"><span class="pre">while</span></code>문을 탈출할 수 있습니다. 그리고 <code class="docutils literal notranslate"><span class="pre">flag</span></code>는 1이 됩니다. 이후 이 쓰레드가 동작을 끝마치면 <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>을 호출하여 <code class="docutils literal notranslate"><span class="pre">flag</span></code> 값을 다시 0으로 변경합니다.</p>
<p>처음 쓰레드가 락을 획득하여 <code class="docutils literal notranslate"><span class="pre">flag</span></code>가 1인 상태에서, 두 번째 쓰레드가 <code class="docutils literal notranslate"><span class="pre">lock()</span></code>을 호출한다고 해보자. <code class="docutils literal notranslate"><span class="pre">TestAndSet(flag,</span> <span class="pre">1)</span></code>을 호출하면 반환 값이 1 이라 <code class="docutils literal notranslate"><span class="pre">while</span></code>문을 탈출할 수 없습니다. 락을 보유하고 있는 쓰레드가 존재하는 한 <code class="docutils literal notranslate"><span class="pre">TestAndSet(flag,</span> <span class="pre">1)</span></code>은 계속 1을 반환합니다.</p>
<p>락을 보유하고 있는 처음 쓰레드가 <code class="docutils literal notranslate"><span class="pre">flag</span></code> 값을 0으로 변경하면, 두 번째 쓰레드가 <code class="docutils literal notranslate"><span class="pre">TestAndSet(flag,</span> <span class="pre">1)</span></code>을 호출했을 때 반환 값이 0이 되어 <code class="docutils literal notranslate"><span class="pre">while</span></code>문을 탈출할 수 있게 됩니다.</p>
<p>드디어 제대로 동작하는 상호 배제 함수를 만드는 방법을 배웠습니다. 이것이 가장 기초적인 형태의 락으로써, 락을 획득할 때까지 CPU 사이클을 소모하면서 회전합니다. 단일 프로세서에서 이 방식을 제대로 사용하려면 선점형 스케줄러를 사용해야 합니다. 다른 쓰레드가 실행될 수 있도록 타이머를 통해 인터럽트를 발생시킬 수 있기 때문입니다. 선점형이 아니면 <code class="docutils literal notranslate"><span class="pre">while</span></code>문을 돌리며 대기하는 쓰레드가 CPU를 영원히 독점하게 될 것입니다.</p>
</section>
<section id="id11">
<h2>스핀 락 평가<a class="headerlink" href="#id11" title="Link to this heading">#</a></h2>
<p>락에서 가장 중요한 측면은 상호 배제의 정확성 입니다. 상호 배제가 가능하다면 스핀 락은 임의의 시간에 단 하나의 쓰레드만이 임계 영역에 진입할 수 있도록 합니다.</p>
<p>그 다음의 항목은 공정성입니다. 대기 중인 쓰레드들에 있어서 스핀 락은 얼마나 공정할까? 스핀 락은 어떠한 공정성도 보장해줄 수 없습니다. <code class="docutils literal notranslate"><span class="pre">while</span></code>문을 돌리는 쓰레드가 경쟁에 밀려서 굶주릴 가능성이 존재합니다.</p>
<p>마지막 항목은 성능입니다. 스핀 락을 사용할 때 얼마나 비용을 지불해야 할까? 단일 CPU의 경우 스핀 락이 갖는 성능 오버헤드는 상당히 클 수 있습니다.
𝑁개 중 𝑁 − 1개의 다른 쓰레드가 락을 획득하려고 할 때, 스케줄러가 이들을 한 번씩 깨울 수도 있습니다. CPU가 여러 개인 경우 (쓰레드의 개수와 CPU의 개수가 비슷하다면) 스핀 락은 꽤 합리적으로 동작합니다. CPU 1에서 실행중인 A가 락을 획득한 후 B가 락을 획득하려고 한다면 CPU 2에서 기다리기 때문에 금방 락을 획득할 수 있을 것입니다.</p>
</section>
<section id="compare-and-swap">
<h2>Compare-And-Swap<a class="headerlink" href="#compare-and-swap" title="Link to this heading">#</a></h2>
<p>또 다른 하드웨어 기법은 SPARC의 <em>Compare-And-Swap</em>, x86의 <em>Compare-And-Exchange</em>가 있습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>int<span class="w"> </span>CompareAndSwap<span class="o">(</span>int<span class="w"> </span>*ptr,<span class="w"> </span>int<span class="w"> </span>expected,<span class="w"> </span>int<span class="w"> </span>new<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span><span class="nv">actual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>*ptr<span class="p">;</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="nv">actual</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>expected<span class="o">)</span>
<span class="w">		</span>*ptr<span class="w"> </span><span class="o">=</span><span class="w"> </span>new<span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span>actual<span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Compare-And-Swap 기법의 기본 개념은 <code class="docutils literal notranslate"><span class="pre">ptr</span></code>이 가리키고 있는 주소의 값이 <code class="docutils literal notranslate"><span class="pre">expected</span></code> 변수와 일치하는지 검사하는 것입니다. 만약 일치한다면 <code class="docutils literal notranslate"><span class="pre">ptr</span></code>이 가리키는 주소의 값을 새로운 값으로 변경합니다. 불일치한다면 변경하지 않습니다. 원래의 메모리 값을 반환하여 <code class="docutils literal notranslate"><span class="pre">CompareAndSwap</span></code>을 호출한 코드가 락 획득의 성공 여부를 알 수 있도록 합니다.</p>
<p>앞서 작성한 Test-And-Set 방법을 사용했을 때와 같은 방법으로 락을 만들 수 있습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>typedef<span class="w"> </span>struct<span class="w"> </span>__lock_t<span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>flag<span class="p">;</span>
<span class="o">}</span><span class="w"> </span>lock_t<span class="p">;</span>

void<span class="w"> </span>init<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>//<span class="w"> </span>0은<span class="w"> </span>락이<span class="w"> </span>획득<span class="w"> </span>가능한<span class="w"> </span>상태
<span class="w">	</span>//<span class="w"> </span>1은<span class="w"> </span>락을<span class="w"> </span>획득했음
<span class="w">	</span>lock−&gt;flag<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>lock<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="k">while</span><span class="w"> </span><span class="o">(</span>CompareAndSwap<span class="o">(</span><span class="p">&amp;</span>lock−&gt;flag,<span class="w"> </span><span class="m">0</span>,<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="o">)</span>
<span class="w">	</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>spin
<span class="o">}</span>

void<span class="w"> </span>unlock<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>lock−&gt;flag<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>맨 처음 락을 획득하는 쓰레드는, 0을 1로 바꾸는데 성공해서 0을 반환받고 (actual == 0) 루프를 탈출합니다. 그 이후 접근하는 쓰레드는 <code class="docutils literal notranslate"><span class="pre">expected</span></code>는 0, <code class="docutils literal notranslate"><span class="pre">flag는</span></code> 1이라 1을 반환받고 <em>(actual == 1)</em> 루프를 탈출할 수 없습니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">CompareAndSwap</span></code> 명령어는 <code class="docutils literal notranslate"><span class="pre">TestAndSet</span></code> 명령어보다 더 강력합니다. 대기없는 동기화 <em>(wait-free synchronization)</em> 을 다룰 때 강력함을 알게 될 것입니다.</p>
</section>
<section id="fetch-and-add">
<h2>Fetch-And-Add<a class="headerlink" href="#fetch-and-add" title="Link to this heading">#</a></h2>
<p>마지막 하드웨어 기법은 <em>Fetch-And-Add</em> 명령어로, 원자적으로 특정 주소의 예전 값을 반환하면서 값을 증가시킵니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>int<span class="w"> </span>FetchAndAdd<span class="o">(</span>int<span class="w"> </span>*ptr<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span><span class="nv">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>*ptr<span class="p">;</span>
<span class="w">	</span>*ptr<span class="w"> </span><span class="o">=</span><span class="w"> </span>old<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span>old<span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">FetchAndAdd</span></code> 명령어를 사용하여 티켓 락을 만들어보자.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>typedef<span class="w"> </span>struct<span class="w"> </span>__lock_t<span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>ticket<span class="p">;</span>
<span class="w">	</span>int<span class="w"> </span>turn<span class="p">;</span>
<span class="o">}</span><span class="w"> </span>lock_t<span class="p">;</span>

void<span class="w"> </span>lock_init<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>lock−&gt;ticket<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">	</span>lock−&gt;turn<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>lock<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span><span class="nv">myturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>FetchAndAdd<span class="o">(</span><span class="p">&amp;</span>lock−&gt;ticket<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="o">(</span>lock−&gt;turn<span class="w"> </span>!<span class="o">=</span><span class="w"> </span>myturn<span class="o">)</span>
<span class="w">	</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>spin
<span class="o">}</span>

void<span class="w"> </span>unlock<span class="o">(</span>lock_t<span class="w"> </span>*lock<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>FetchAndAdd<span class="o">(</span><span class="p">&amp;</span>lock−&gt;turn<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ticket</span></code>과 <code class="docutils literal notranslate"><span class="pre">turn</span></code> 조합을 사용해 락을 만든다. 하나의 쓰레드가 락 획득을 원하면, <code class="docutils literal notranslate"><span class="pre">ticket</span></code> 변수에 atomic 연산인 <code class="docutils literal notranslate"><span class="pre">FetchAndAdd</span></code> 명령어를 실행합니다. 결과 값은 해당 쓰레드의 차례를 나타냅니다.</p>
<p>전역 공유 변수인 <code class="docutils literal notranslate"><span class="pre">lock-&gt;turn</span></code>을 사용하여 어느 쓰레드의 차례인지 판단합니다. 만약 한 쓰레드가 <code class="docutils literal notranslate"><span class="pre">myturn</span> <span class="pre">==</span> <span class="pre">lock-&gt;turn</span></code>조건에 부합하면, <code class="docutils literal notranslate"><span class="pre">while</span></code> 문을 벗어나 락을 획득합니다. <code class="docutils literal notranslate"><span class="pre">unlock()</span></code>은 <code class="docutils literal notranslate"><span class="pre">turn</span></code> 변수의 값을 증가시켜서 대기 중인 다음 쓰레드에게 임계 영역 진입 차례를 넘겨 줍니다.</p>
<p>이전까지 접근 방법과의 가장 중요한 차이점은 모든 쓰레드들이 각자의 순서에 따라 진행한다는 것입니다. 쓰레드가 티켓 값을 할당받았다면, 미래의 어느 시점에 실행되기 위해 스케줄되어 있다는 것입니다. 이전까지는 이러한 보장이 없었습니다. 예를 들어 <code class="docutils literal notranslate"><span class="pre">Test-And-Set</span></code>의 경우 다른 쓰레드들은 락을 획득/해제하더라도 어떤 쓰레드는 계속 회전만 하고 있을 수 있습니다. 즉 이번 해법은 공정성이 있습니다.</p>
</section>
<section id="id12">
<h2>요약: 과도한 스핀<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<p>과도한 스핀은 스핀락을 사용할 때 발생하는 문제로, 다른 스레드가 락을 획득할 때까지 무한히 반복하여 락을 대기하는 상황을 말합니다. 이는 스핀락을 사용하는 스레드가 계속해서 프로세서를 점유하며 무한 루프를 돌게 되어 CPU 자원을 낭비하게 됩니다. 이러한 상황은 일반적으로 다음과 같은 상황에서 발생할 수 있습니다.</p>
<ol class="arabic simple">
<li><p>락의 소유자가 긴 시간동안 락을 소유:</p>
<ul class="simple">
<li><p>락을 획득한 스레드가 긴 시간동안 락을 소유하고 다른 스레드에게 양보하지 않는 경우, 대기 중인 스레드들이 계속해서 무한 루프를 돌며 락을 대기하게 됩니다.</p></li>
</ul>
</li>
<li><p>락을 짧은 시간동안 획득할 수 있는 경쟁이 심한 상황:</p>
<ul class="simple">
<li><p>많은 스레드가 락을 경쟁적으로 획득하려는 경우, 한 스레드가 락을 획득한 뒤 즉시 다른 스레드가 락을 요청할 수 있습니다. 이런 경우 락을 획득한 스레드가 락을 반납하지 않고 계속해서 락을 소유하려는 경향이 있습니다.</p></li>
</ul>
</li>
</ol>
<p>과도한 락 스핀은 CPU 자원의 낭비를 초래하며 전반적인 시스템 성능을 저하시킬 수 있습니다. 이를 해결하기 위해서는 락을 짧은 시간동안만 소유하도록 하거나, 대기 중인 스레드들에게 락을 양보하는 방법을 사용할 수 있습니다.</p>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="ypilseong" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/ypilseong">양필성</a></p>
</aside>
</aside>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "chu-aie/os-2024",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./week11"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="index.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Week 11 - 병행성 2</p>
      </div>
    </a>
    <a class="right-next"
       href="threads-locks-usage.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">락 기반의 병행 자료 구조</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">락: 기본 개념</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pthread">Pthread 락</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">세밀한 락과 거친 락 전략</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">락 구현</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">락의 평가</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">인터럽트 제어</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#test-and-set-atomic-exchange">Test-And-Set (Atomic Exchange)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">정확성</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">성능</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">진짜 돌아가는 스핀 락의 구현</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">스핀 락 평가</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#compare-and-swap">Compare-And-Swap</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fetch-and-add">Fetch-And-Add</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">요약: 과도한 스핀</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By <a href='https://entelecheia.me/'>Young Joon Lee</a>
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <script
  data-embed-id="8f8d1c1a-0e3e-428a-a8a6-26acd215e1fe"
  data-base-api-url="https://chat.entelecheia.app/api/embed"
  data-brand-image-url="https://assets.entelecheia.ai/favicon.png"
  data-chat-icon="magic"
  data-sponsor-text="OS 2024"
  data-sponsor-link="https://chat.entelecheia.app/workspace/os2024"
  src="https://chat.entelecheia.app/embed/anythingllm-chat-widget.min.js">
</script>

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>