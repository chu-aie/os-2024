
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>컨디션 변수 &#8212; 운영체제 2024</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-examples.css?v=e236af4b" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster.bundle.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-shadow.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-punk.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-noir.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-light.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/tooltipster-sideTip-borderless.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/micromodal.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=87e54e7c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script src="../_static/tabs.js?v=3ee01567"></script>
    <script src="../_static/js/hoverxref.js"></script>
    <script src="../_static/js/tooltipster.bundle.min.js"></script>
    <script src="../_static/js/micromodal.min.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-BQJE5V9RK2"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-BQJE5V9RK2');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-BQJE5V9RK2');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"N": "\\mathbb{N}", "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'week12/threads-cv';</script>
    <link rel="icon" href="https://assets.entelecheia.ai/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="세마포어" href="threads-sema.html" />
    <link rel="prev" title="Week 12 - 병행성 3" href="index.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>


  <div class="bd-header-announcement container-fluid bd-header-announcement">
    <div class="bd-header-announcement__content">5/22일(수) 수업은 휴강입니다. 보강은 6/11일(화) 14:00에 진행됩니다.</div>
  </div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">운영체제 2024</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../index.html">
                    Home
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Lecture Notes</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../week01/index.html">Week 1 - 아주 쉬운 세 가지 이야기</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week01/dialogue.html">이 책에 관한 대화</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week01/intro.html">운영체제 개요</a></li>
<li class="toctree-l2"><a class="reference external" href="https://learn.microsoft.com/ko-kr/windows/wsl/install">WSL 설치방법</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week02/index.html">Week 2 - 가상화의 세계</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week02/dialogue.html">가상화에 관한 대화</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/cpu-intro.html">프로세스의 개념</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/cpu-api.html">프로세스 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/cpu-mechanisms.html">제한적 직접 실행 원리</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/shells.html">리눅스 셸 (Linux Shells)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/lab.html">Lab: Shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/tip.html">Tip: 리눅스 프로세스 관리 명령어</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week02/hw-wk02.html">Homework: 프로세스</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week03/index.html">Week 3 - 스케줄링 1</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week03/cpu-scheduling.html">스케줄링: 개요</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week03/lab.html">Lab: 프로세스 생성과 실행 기초</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week03/wsl-setup.html">WSL에서 Ubuntu 환경구축 및 GitHub 설정하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week03/hw-wk03.html">Homework: 스케줄링</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week04/index.html">Week 4 - 스케줄링 2</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week04/mlfq.html">스케줄링: 멀티 레벨 피드백 큐</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/lottery.html">스케줄링: 비례 배분</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/dialogue.html">CPU 가상화 마무리 대화</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/lab-sched.html">Lab: 스케줄링 알고리즘 시뮬레이터</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/lab-lottery.html">Lab: Lottery 스케줄링 알고리즘 구현</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week04/hw-wk04.html">Homework: 비례 배분</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week05/index.html">Week 5 - 메모리 가상화 1</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week05/vm-intro.html">주소 공간의 개념</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week05/vm-api.html">메모리 관리 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week05/lab.html">Lab: 메모리 구조 탐색하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week05/tip-linux-cmd.html">Tip: Linux 기본 명령어</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week06/index.html">Week 6 - 메모리 가상화 2</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week06/vm-mechanism.html">주소 변환의 원리</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week06/vm-segmentation.html">세그멘테이션 </a></li>
<li class="toctree-l2"><a class="reference internal" href="../week06/lab.html">Lab: 주소 변환 시뮬레이션</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week06/hw-wk06.html">Homework: 주소 변환의 원리</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week07/index.html">Week 7 - 메모리 가상화 3</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week07/vm-freespace.html">빈 공간 관리</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week07/hw-wk07.html">Homework: 빈 공간 관리</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week09/index.html">Week 9 - 메모리 가상화 4</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week09/vm-paging.html">페이징: 개요</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week09/vm-tlbs.html">페이징: 더 빠른 변환 (TLB)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week09/vm-swap.html">물리 메모리 크기의 극복: 메커니즘</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week10/index.html">Week 10 - 병행성에 관한 대화</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week10/threads-intro.html">병행성: 개요</a></li>
<li class="toctree-l2"><a class="reference internal" href="../week10/threads-api.html">쓰레드 API</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../week11/index.html">Week 11 - 병행성 2</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../week11/threads-locks.html">락 </a></li>
<li class="toctree-l2"><a class="reference internal" href="../week11/threads-locks-usage.html">락 기반의 병행 자료 구조</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">Week 12 - 병행성 3</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 current active"><a class="current reference internal" href="#">컨디션 변수</a></li>
<li class="toctree-l2"><a class="reference internal" href="threads-sema.html">세마포어</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Projects</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../projects/index.html">OS 프로젝트</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../projects/202121006/index.html">reverse 프로젝트</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-13"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk02.html">Week 2 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk03.html">Week 3 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk04.html">Week 4 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk06.html">Week 6 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121006/hw-wk07.html">Week 7 Homework</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../projects/202121010/index.html">Key-Value store project by ypilseong</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-14"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../projects/202121010/homework.html">Homework</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../projects/202221014/index.html">프로젝트: Key-Value Store 구현</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-15"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../projects/202221014/hw-wk02.html">Week 2 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202221014/hw-wk03.html">Week 3 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202221014/hw-wk04.html">Week 4 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202221014/hw-wk06.html">Week 6 Homework</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../projects/202321007/index.html">리버스 프로젝트 개요</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projects/202321010/index.html">reverse 프로젝트</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../projects/202321017/index.html">grep 프로젝트</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-16"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../projects/202321017/hw-wk02.html">Week 2 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202321017/hw-wk03.html">Week 3 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202321017/hw-wk04.html">Week 4 Homework</a></li>
<li class="toctree-l3"><a class="reference internal" href="../projects/202321017/hw-wk06.html">Week 6 Homework</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../projects/contents/index.html">프로젝트 과제 목록</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-17"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../projects/contents/utilities.html">유닉스 유틸리티 프로젝트</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projects/contents/reverse.html"><code class="docutils literal notranslate"><span class="pre">reverse</span></code> 프로젝트</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projects/contents/kv.html"><code class="docutils literal notranslate"><span class="pre">kv</span></code> 프로젝트: 간단한 키-값 저장소</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../projects/lab-tutorial.html">Lab 튜토리얼</a></li>
<li class="toctree-l1"><a class="reference internal" href="../projects/tester.html">프로젝트 테스터</a></li>
<li class="toctree-l1"><a class="reference internal" href="../projects/setup.html">프로젝트 환경설정</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../references/ostep/index.html">OSTEP (Korean Version)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/ostep-code/index.html">ostep-code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/ostep-homework/index.html">Homeworks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/ostep-projects/index.html">Projects</a></li>
<li class="toctree-l1"><a class="reference external" href="https://kuleuven-diepenbeek.github.io/osc-course/">Operating Systems and C</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../syllabus/index.html">수업계획서</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">만든 사람들</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference external" href="https://halla.ai">인공지능학과</a></li>
<li class="toctree-l1"><a class="reference external" href="https://os2024.halla.ai">운영체제 2024</a></li>
<li class="toctree-l1"><a class="reference external" href="https://mlops2024.halla.ai">머신러닝시스템 2024</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cobots2024.halla.ai">협동로봇활용 2024</a></li>
<li class="toctree-l1"><a class="reference external" href="https://aibasics.halla.ai">AI 세상 속으로</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/chu-aie/os-2024" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/chu-aie/os-2024/edit/main/src/os2024/book/week12/threads-cv.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/chu-aie/os-2024/issues/new?title=Issue%20on%20page%20%2Fweek12/threads-cv.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/week12/threads-cv.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>컨디션 변수</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">정의와 루틴들</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">첫 번째 케이스</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">두 번째 케이스</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">생산자/소비자 (유한 버퍼) 문제</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">첫 번째 문제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#if-while">해결 방법: if -&gt; while</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">두 번째 문제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">단일 버퍼 생산자/소비자 해법</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">최종적인 생산자/소비자 해법</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">컨디션 변수 사용 시 주의점</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">요약</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>컨디션 변수<a class="footnote-reference brackets" href="#ypilseong" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a><a class="headerlink" href="#id2" title="Link to this heading">#</a></h1>
<p>우리가 배운 <em>‘락’</em> 하나만 가지고는 제대로 병행 프로그램을 작성할 수 없습니다. 쓰레드가 계속 진행하기 전에 특정 조건이 만족되었는지 검사가 필요한 경우가 있습니다. 예를 들면 자식 쓰레드가 작업을 끝냈는지 여부를 알 필요가 있습니다. 이런 걸 어떻게 구현할 수 있을까요?</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>volatile<span class="w"> </span>int<span class="w"> </span><span class="k">done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

void<span class="w"> </span>*child<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>printf<span class="o">(</span>“child<span class="se">\n</span><span class="w"> </span>”<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span>NULL<span class="p">;</span>
<span class="o">}</span>

int<span class="w"> </span>main<span class="o">(</span>int<span class="w"> </span>argc,<span class="w"> </span>char<span class="w"> </span>*argv<span class="o">[])</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>printf<span class="o">(</span>“parent:<span class="w"> </span>begin<span class="se">\n</span><span class="w"> </span>”<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>pthread_t<span class="w"> </span>c<span class="p">;</span>
<span class="w">	</span>Pthread_create<span class="o">(</span><span class="p">&amp;</span>c,<span class="w"> </span>NULL,<span class="w"> </span>child,<span class="w"> </span>NULL<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="k">done</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span>
<span class="w">	</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>spin
<span class="w">	</span>printf<span class="o">(</span>“parent:<span class="w"> </span>end<span class="se">\n</span><span class="w"> </span>”<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>이렇게 공유 변수로 구현할 수 있다 하지만 부모 쓰레드가 <code class="docutils literal notranslate"><span class="pre">spin</span></code> 하면서 자원을 낭비하고 있습니다. 이 방법 대신 부모 쓰레드가 특정 조건이 만족될때까지 잠자면서 기다리는 것이 더 좋습니다.</p>
<section id="id3">
<h2>정의와 루틴들<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>조건이 참이 될 때까지 기다리기 위해 컨디션 변수를 활용할 수 있다습니다. 션 변수는 일종으 큐 자료 구조로서, 어떤 실행의 상태 (또는 어떤 조건) 가 원하는 것과 다를 때 참이 되기를 기다리며 스레드가 대기할 수 있는 큐입니다. 다른 쓰레드가 상태를 변경시켰을 때, 대기 중이던 쓰레드를 깨우고, 계속 진행할 수 있도록 합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">pthread_cond_t</span> <span class="pre">c;</span></code> 라고 써서 <code class="docutils literal notranslate"><span class="pre">c</span></code>가 컨디션 변수가 되도록 선언하고 초기화합니다. 컨디션 변수에는 <code class="docutils literal notranslate"><span class="pre">wait()</span></code> 과 <code class="docutils literal notranslate"><span class="pre">signal()</span></code> 이라는 두 가지 연산이 존재합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">wait()</span></code> 은 쓰레드가 스스로를 잠재우기 위해 호출하는 것이고, <code class="docutils literal notranslate"><span class="pre">signal()</span></code>은 쓰레드가 무엇인가를 변경했기 때문에 조건이 참이 되기를 기다리며 잠자고 있던 쓰레드를 깨울 때 호출합니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pthread_cond_wait<span class="o">(</span>pthread_cond_t<span class="w"> </span>*c,<span class="w"> </span>pthread_mutex_t<span class="w"> </span>*m<span class="o">)</span><span class="p">;</span>
pthread_cond_signal<span class="o">(</span>pthread_cond_t<span class="w"> </span>*c<span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">wait()</span></code>에서 유의할 점은 <code class="docutils literal notranslate"><span class="pre">mutex</span></code>를 매개변수로 사용한다는 것입니다. 호출될 때 <code class="docutils literal notranslate"><span class="pre">mutex</span></code>는 잠겨있었다고 가정하자. <code class="docutils literal notranslate"><span class="pre">wait()</span></code>의 역할은 락을 해제하고 호출한 쓰레드를 재우는 것입니다. 어떤 다른 쓰레드가 시그널을 보내서 쓰레드가 깨어나면, <code class="docutils literal notranslate"><span class="pre">wait()</span></code>에서 리턴하기 전에 락을 재획득해야 한다.</p>
<p>즉, 조건이 만족되어 잠에서 깨어났더라고 락을 획득하지 못하면 다시 잠에 드는 것입니다. 이렇게 복잡한 이유는 쓰레드가 스스로를 재우려고 할 때, 경쟁 조건의 발생을 방지하기 위해서입니다.</p>
<p>이해를 돕기 위해 예제를 살펴보자.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>int<span class="w"> </span><span class="k">done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
pthread_mutex_t<span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>PTHREAD_MUTEX_INITIALIZER<span class="p">;</span>
pthread_cond_t<span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>PTHREAD_COND_INITIALIZER<span class="p">;</span>

void<span class="w"> </span>thr_exit<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">	</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>c<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>*child<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>printf<span class="o">(</span>“child<span class="se">\n</span><span class="w"> </span>”<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>thr_exit<span class="o">()</span><span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span>NULL<span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>thr_join<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="k">done</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span>
<span class="w">		</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>c,<span class="w"> </span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

int<span class="w"> </span>main<span class="o">(</span>int<span class="w"> </span>argc,<span class="w"> </span>char<span class="w"> </span>*argv<span class="o">[])</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>printf<span class="o">(</span>“parent:<span class="w"> </span>begin<span class="se">\n</span><span class="w"> </span>”<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>pthread_t<span class="w"> </span>p<span class="p">;</span>
<span class="w">	</span>Pthread_create<span class="o">(</span><span class="p">&amp;</span>p,<span class="w"> </span>NULL,<span class="w"> </span>child,<span class="w"> </span>NULL<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>thr_join<span class="o">()</span><span class="p">;</span>
<span class="w">	</span>printf<span class="o">(</span>“parent:<span class="w"> </span>end<span class="se">\n</span><span class="w"> </span>”<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-notice notranslate"><div class="highlight"><pre><span></span>부모 쓰레드가 조건을 검사할 때 `if`문이 아니라 `while`문을 사용합니다.
</pre></div>
</div>
<section id="id4">
<h3>첫 번째 케이스<a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<p>부모 쓰레드가 자식 쓰레드를 생성하고, 계속 실행하며 <code class="docutils literal notranslate"><span class="pre">thr_join()</span></code>을 호출하고, 자식 쓰레드가 끝나기를 기다리는 경우입니다. 이 경우 부모 쓰레드가 락을 획득하고 자식이 끝났는지 검사한 후에 자식이 끝나지 않았으므로 <code class="docutils literal notranslate"><span class="pre">wait()</span></code>을 호출하여 스스로를 잠재우고, 락을 해제합니다. 자식 쓰레드가 추후 실행되어 <code class="docutils literal notranslate"><span class="pre">thr_exit()</span></code>을 호출하여 부모 쓰레드를 깨웁니다. 호출했던 <code class="docutils literal notranslate"><span class="pre">wait()</span></code>에서 락을 획득한 채로 리턴하여 부모 쓰레드가 실행되고, 락을 해제한 후 종료됩니다.</p>
</section>
<section id="id5">
<h3>두 번째 케이스<a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<p>자식 쓰레드가 생성되면서 즉시 실행되고, <code class="docutils literal notranslate"><span class="pre">done</span></code> 을 1로 설정하고, 자고 있는 쓰레드를 깨우기 위해 시그널을 보냅니다. 하지만 자고 있는 쓰레드가 없기 때문에 그냥 리턴합니다. 그 후 부모 쓰레드가 실행되고 <code class="docutils literal notranslate"><span class="pre">thr_join()</span></code>을 호출하고 <code class="docutils literal notranslate"><span class="pre">done</span></code>이 1이므로 바로 리턴합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">thr_exit()</span></code>, <code class="docutils literal notranslate"><span class="pre">thr_join()</span></code>의 중요성을 이해할 수 있도록 몇 가지 구현의 방식을 살펴보자.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>void<span class="w"> </span>thr_exit<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>c<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>thr_join<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>c,<span class="w"> </span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>이런 식으로 작성된 경우는 두 번째 케이스, 자식 쓰레드가 생성된 즉시 실행되어 <code class="docutils literal notranslate"><span class="pre">thr_exit()</span></code>을 호출하는 경우에 제대로 작동하지 않습니다. 자식 프로세스가 시그널을 보내지만, 깨울 쓰레드가 없어 리턴됩니다. 부모 쓰레드는 <code class="docutils literal notranslate"><span class="pre">wait()</span></code>을 호출하고 거기서 멈춰있게 됩니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>void<span class="w"> </span>thr_exit<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span><span class="k">done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">	</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>c<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>thr_join<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="k">done</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span>
<span class="w">		</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>c<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>이런 식으로 작성된 경우, 경쟁 조건이 발생합니다. 부모 쓰레드가 <code class="docutils literal notranslate"><span class="pre">thr_join()</span></code>을 호출하고 나서 <code class="docutils literal notranslate"><span class="pre">done</span></code>이 <code class="docutils literal notranslate"><span class="pre">0</span></code>인 것을 확인하고 <code class="docutils literal notranslate"><span class="pre">wait()</span></code>을 호출하기 직전에 인터럽트에 걸려 자식 쓰레드가 실행되었다고 해보자. 자식 쓰레드는 <code class="docutils literal notranslate"><span class="pre">done</span></code>을 <code class="docutils literal notranslate"><span class="pre">1</span></code>로 변경하고 시그널을 보내지만 대기 중인 쓰레드가 없습니다. 다시 부모 쓰레드가 실행되면, <code class="docutils literal notranslate"><span class="pre">wait()</span></code>을 호출하고 잠에 들지만 아무도 깨워 줄 수 없습니다.</p>
</section>
</section>
<section id="id6">
<h2>생산자/소비자 (유한 버퍼) 문제<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p>다음으로 살펴볼 동기화 문제는 Dijkstra가 처음 제시한 생산자/소비자(producer/consumer) 문제입니다. 유한 버퍼(bounded 버퍼) 문제로도 알려져 있습니다. <code class="docutils literal notranslate"><span class="pre">lock</span></code> 대신 일반화된 세마포어를 발명하게 된 이유가 이 문제 때문입니다.</p>
<p>여러 개의 생산자 쓰레드와 소비자 쓰레드가 있다고 하자. 생산자는 데이터를 만들어 버퍼에 넣고, 소비자는 버퍼에서 데이터를 꺼내어 사용합니다. 이러한 관계는 실제로 시스템에서 자주 일어납니다. 예를 들어 멀티 쓰레드 웹 서버의 경우 생산자는 HTTP 요청을 작업 큐 (유한 버퍼) 에 넣고, 소비자 쓰레드는 이 큐에서 요청을 꺼내어 처리합니다.</p>
<p><code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">foo</span> <span class="pre">file.txt</span> <span class="pre">|</span> <span class="pre">wc</span> <span class="pre">-l</span></code>와 같은 문장처럼 파이프 명령으로 한 프로그램의 결과를 다른 프로그램에게 전달할 때도 유한 버퍼를 사용합니다. UNIX 쉘은 출력 결과를 <em>UNIX 파이프</em> 라는 곳으로 전송합니다. 파이프의 한쪽 끝에는 <code class="docutils literal notranslate"><span class="pre">wc</span></code> 프로세스의 표준 입력과 연결되어 있습니다. <code class="docutils literal notranslate"><span class="pre">grep</span></code> 프로세스가 생산자가 되고 <code class="docutils literal notranslate"><span class="pre">wc</span></code> 프로세스가 소비자가 됩니다.</p>
<p>유한 버퍼는 공유 자원이고, 경쟁 조건의 발생을 방지하기 위해 동기화가 필요합니다. 한 개의 정수를 사용하고, 공유 버퍼에 값을 넣는 함수, 값을 꺼내는 함수 두 개가 있습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>int<span class="w"> </span>buffer<span class="p">;</span>
int<span class="w"> </span><span class="nv">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

void<span class="w"> </span>put<span class="o">(</span>int<span class="w"> </span>value<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>assert<span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="nv">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">	</span><span class="nv">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="o">}</span>

int<span class="w"> </span>get<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>assert<span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="nv">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span>buffer<span class="p">;</span>
<span class="o">}</span>
cond_t<span class="w"> </span>cond<span class="p">;</span>
mutex_t<span class="w"> </span>mutex<span class="p">;</span>

void<span class="w"> </span>*producer<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>i<span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="o">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>loops<span class="p">;</span><span class="w"> </span>i++<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">		</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p1
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span>//<span class="w"> </span>p2
<span class="w">			</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>cond,<span class="w"> </span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p3
<span class="w">		</span>put<span class="o">(</span>i<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p4
<span class="w">		</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>cond<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p5
<span class="w">		</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p6
<span class="w">	</span><span class="o">}</span>
<span class="o">}</span>

void<span class="w"> </span>*consumer<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>i<span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="o">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>loops<span class="p">;</span><span class="w"> </span>i++<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">		</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c1
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span>//<span class="w"> </span>c2
<span class="w">			</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>cond,<span class="w"> </span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c3
<span class="w">		</span>int<span class="w"> </span><span class="nv">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>get<span class="o">()</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c4
<span class="w">		</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>cond<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c5
<span class="w">		</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c6
<span class="w">		</span>printf<span class="o">(</span>“%d<span class="se">\n</span><span class="w"> </span>”,<span class="w"> </span>tmp<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>컨디션 변수 하나와 그것과 연결된 <code class="docutils literal notranslate"><span class="pre">mutex</span></code> 락을 사용하는 방식을 먼저 시도해보자.</p>
<p>생산자는 버퍼가 빌 때까지 기다립니다. 소비자도 버퍼가 차기를 기다립니다. 생산자와 소비자가 각 하나씩인 경우에 위의 코드는 정상적으로 동작합니다. 하지만 생산자, 소비자가 두 개 이상씩 존재하는 경우에는 문제가 있습니다.</p>
<section id="id7">
<h3>첫 번째 문제<a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<p>대기 명령 전의 <code class="docutils literal notranslate"><span class="pre">if</span></code> 문과 관련이 있다.</p>
<p>Tc1 과 Tc2 라는 두 개의 소비자가 있고 Tp 라는 생산자가 하나 있다고 가정하자. 소비자 (Tc1)가 먼저 실행됩니다. 락 (c1) 을 획득하고 버퍼를 소비할 수 있는지 검사한다 (c2). 그리고 비어있음을 확인한 후에 대기하며 (c3) 락을 해제합니다. 그리고 생산자 (Tp)가 실행됩니다. 락을 획득하고 (p1) 버퍼가 비었는지 확인합니다 (p2). 비었음을 발견하고, 버퍼를 채웁니다 (p4). 생산자는 버퍼가 가득 찼다는 시그널을 보냅니다 (p5). 대기 중인 첫째 소비자 (Tc1)는 깨어나 준비 큐 (ready queue)로 이동합니다. Tc1 은 이제 실행할 수 있는 상태이지만 아직 실행 상태는 아닙니다. 생산자는 실행을 계속합니다. 버퍼가 차 있으므로 대기 상태로 전이합니다 (p6, p1-p3).</p>
<p>여기에서 문제가 발생합니다. 다른 소비자 (Tc2)가 끼어들어서 실행하면서 버퍼 값을 소비합니다 (c1, c2, c4, c5, c6을 수행, c3은 버퍼가 가득 찼기 때문에 건너뜀). Tc1 이 실행된다고 해보자. 대기에서 리턴하기 전에 락을 획득합니다. 그리고 get()을 호출하지만 (c4) 버퍼는 비었습니다. 코드는 의도한 대로 기능하지 못했습니다. 생산자가 버퍼에 넣어 둔 값을 Tc2 가 끼어들어서 소비하였기 때문에 Tc1 이 비어 있는 버퍼를 읽는 행위를 막았어야 했습니다.</p>
<p>문제의 원인은 <em>Tc1이 깨어나서 실행되기까지의 사이에 유한 버퍼의 상태가 변경되었기 때문</em>입니다. 시그널은 쓰레드를 깨우기만 하고, 깨어난 쓰레드가 실제 싱행되는 시점에 그 상태가 유지된다는 보장은 없습니다. 이런 식으로 시그널을 정의하는 것을 <em>Mesa Semantic</em>이라 합니다. 대비되는 개념은 Hoare Semantic인데 구현하기는 더 어렵지만 깨어난 즉시 쓰레드가 실행되는 것을 보장합니다.</p>
</section>
<section id="if-while">
<h3>해결 방법: if -&gt; while<a class="headerlink" href="#if-while" title="Link to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> 문을 <code class="docutils literal notranslate"><span class="pre">while</span></code> 문으로 변경하면 이 문제를 해결할 수 있습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>cond_t<span class="w"> </span>cond<span class="p">;</span>
mutex_t<span class="w"> </span>mutex<span class="p">;</span>

void<span class="w"> </span>*producer<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>i<span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="o">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>loops<span class="p">;</span><span class="w"> </span>i++<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">		</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p1
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span>//<span class="w"> </span>p2
<span class="w">			</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>cond,<span class="w"> </span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p3
<span class="w">		</span>put<span class="o">(</span>i<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p4
<span class="w">		</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>cond<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p5
<span class="w">		</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p6
<span class="w">	</span><span class="o">}</span>
<span class="o">}</span>

void<span class="w"> </span>*consumer<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>i<span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="o">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>loops<span class="p">;</span><span class="w"> </span>i++<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">		</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c1
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span>//<span class="w"> </span>c2
<span class="w">			</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>cond,<span class="w"> </span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c3
<span class="w">		</span>int<span class="w"> </span><span class="nv">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>get<span class="o">()</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c4
<span class="w">		</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>cond<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c5
<span class="w">		</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c6
<span class="w">		</span>printf<span class="o">(</span>“%d<span class="se">\n</span><span class="w"> </span>”,<span class="w"> </span>tmp<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>소비자 Tc1 이 깨어나서 (락을 획득한 상태), 즉시 공유 변수의 상태를 재확인 합니다 (c2). 만약 이 시점에 버퍼가 비어 있다면, 소비자는 대기 상태로 돌아갑니다 (c3). 문제가 해결되었습니다. Mesa semantic의 컨디션 변수에서 가장 기본적인 법칙은 언제나 <code class="docutils literal notranslate"><span class="pre">while</span></code> 문을 사용하라는 것입니다.</p>
</section>
<section id="id8">
<h3>두 번째 문제<a class="headerlink" href="#id8" title="Link to this heading">#</a></h3>
<p>이 문제는 소비자 쓰레드 Tc1 과 Tc2 가 먼저 실행한 후에 둘 다 대기 상태에 있을 때 발생합니다 (c3).</p>
<p>생산자가 실행되어 버퍼에 값을 넣고 대기 중인 쓰레드 하나를 깨우고 (Tc1 을 깨웠다고 하자), 자신은 대기합니다. 이제 하나의 소비자 (Tc1)가 실행할 준비가 되었고 조건에 의해 Tc2 와 Tp 는 대기 중입니다. 이제 문제가 발생하도록 만들 것입니다.</p>
<p>소비자 Tc1이 wait()에서 리턴을 받아 깨어나고 (c3) 조건을 재확인합니다 (c2). 버퍼가 차있다는 것을 발견하고 값을 소비합니다 (c4). 이 소비자는 시그널을 전송하여 (c5) 대기중인 쓰레드 중 하나를 깨운웁니다. 이때 어떤 쓰레드를 깨울 것인가?</p>
<p>소비자가 버퍼를 비웠기 때문에 생산자를 당연히 깨워야 합니다. 하지만, 만약 소비자 Tc2 를 깨운다면 (대기 큐가 어떻게 관리되느냐에 따라 당연히 발생할 수 있습니다), 문제가 발생합니다. 소비자 Tc2 가 깨어나면 버퍼가 비어 있다는 것을 발견한 후에 (c2) 다시 대기 상태로 들어갑니다 (c3). 버퍼에 값을 넣어야 하는 생산자 Tp 는 대기 중입니다. 다른 소비자 쓰레드 Tc1 역시 대기 상태에 들어갑니다. 세 개의 쓰레드가 모두 대기 상태입니다.</p>
<div class="highlight-notice notranslate"><div class="highlight"><pre><span></span>시그널을 보내는 것은 꼭 필요하지만 대상이 명확해야 합니다. 소비자는 다른 소비자를 깨울 수 없고 생산자만 깨워야 하며, 반대로 생산자의 경우도 마찬가지입니다.
</pre></div>
</div>
</section>
<section id="id9">
<h3>단일 버퍼 생산자/소비자 해법<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<p><em>두 개의 컨디션 변수를 사용</em>하여 시스템의 상태가 변경되었을 때 깨워야 하는 쓰레드에게만 시그널을 제대로 전달합니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>cond_t<span class="w"> </span>empty,<span class="w"> </span>fill<span class="p">;</span>
mutex_t<span class="w"> </span>mutex<span class="p">;</span>

void<span class="w"> </span>*producer<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>i<span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="o">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>loops<span class="p">;</span><span class="w"> </span>i++<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">		</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p1
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span>//<span class="w"> </span>p2
<span class="w">			</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>empty,<span class="w"> </span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p3
<span class="w">		</span>put<span class="o">(</span>i<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p4
<span class="w">		</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>fill<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p5
<span class="w">		</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p6
<span class="w">	</span><span class="o">}</span>
<span class="o">}</span>

void<span class="w"> </span>*consumer<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>i<span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="o">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>loops<span class="p">;</span><span class="w"> </span>i++<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">		</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c1
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span>//<span class="w"> </span>c2
<span class="w">			</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>fill,<span class="w"> </span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c3
<span class="w">		</span>int<span class="w"> </span><span class="nv">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>get<span class="o">()</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c4
<span class="w">		</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>empty<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c5
<span class="w">		</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c6
<span class="w">		</span>printf<span class="o">(</span>“%d<span class="se">\n</span><span class="w"> </span>”,<span class="w"> </span>tmp<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</section>
<section id="id10">
<h3>최종적인 생산자/소비자 해법<a class="headerlink" href="#id10" title="Link to this heading">#</a></h3>
<p>마지막 변경을 통해 병행성을 증가시키고 효율적으로 만들어 보자. 버퍼 공간을 추가하여 대기 상태에 들어가기 전에 여러 값들이 생산될 수 있도록 하는 것, 그리고 마찬가지로 여러 개의 값이 대기 상태 전에 생산될 수 있도록 하는 것입니다.</p>
<p>우선 다음과 같이 버퍼 구조와 <code class="docutils literal notranslate"><span class="pre">put()</span></code>, <code class="docutils literal notranslate"><span class="pre">get()</span></code> 함수를 변경하였습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>int<span class="w"> </span>buffer<span class="o">[</span>MAX<span class="o">]</span><span class="p">;</span>
int<span class="w"> </span><span class="nv">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
int<span class="w"> </span><span class="nv">use</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
int<span class="w"> </span><span class="nv">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>

void<span class="w"> </span>put<span class="o">(</span>int<span class="w"> </span>value<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>buffer<span class="o">[</span>fill<span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>value<span class="p">;</span>
<span class="w">	</span><span class="nv">fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span>fill<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span>%<span class="w"> </span>MAX<span class="p">;</span>
<span class="w">	</span>count++<span class="p">;</span>
<span class="o">}</span>

int<span class="w"> </span>get<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span><span class="nv">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>buffer<span class="o">[</span>use<span class="o">]</span><span class="p">;</span>
<span class="w">	</span><span class="nv">use</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span>use<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span>%<span class="w"> </span>MAX<span class="p">;</span>
<span class="w">	</span>count−−<span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span>tmp<span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>생산자와 소비자의 대기 상태 로직도 변경하였습니다.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>cond_t<span class="w"> </span>empty,<span class="w"> </span>fill<span class="p">;</span>
mutex_t<span class="w"> </span>mutex<span class="p">;</span>

void<span class="w"> </span>*producer<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>i<span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="o">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>loops<span class="p">;</span><span class="w"> </span>i++<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">		</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p1
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>MAX<span class="o">)</span><span class="w"> </span>//<span class="w"> </span>p2
<span class="w">			</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>empty,<span class="w"> </span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p3
<span class="w">		</span>put<span class="o">(</span>i<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p4
<span class="w">		</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>fill<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p5
<span class="w">		</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>p6
<span class="w">	</span><span class="o">}</span>
<span class="o">}</span>

void<span class="w"> </span>*consumer<span class="o">(</span>void<span class="w"> </span>*arg<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>int<span class="w"> </span>i<span class="p">;</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span><span class="o">(</span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>i<span class="w"> </span>&lt;<span class="w"> </span>loops<span class="p">;</span><span class="w"> </span>i++<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">		</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c1
<span class="w">		</span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="nv">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span>//<span class="w"> </span>c2
<span class="w">			</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>fill,<span class="w"> </span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c3
<span class="w">		</span>int<span class="w"> </span><span class="nv">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>get<span class="o">()</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c4
<span class="w">		</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>empty<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c5
<span class="w">		</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>mutex<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>c6
<span class="w">		</span>printf<span class="o">(</span>“%d<span class="se">\n</span><span class="w"> </span>”,<span class="w"> </span>tmp<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>생산자는 모든 버퍼가 현재 가득 차 있다면 대기 상태에 들어가고, 소비자도 모든 버퍼가 비어 있다면 대기에 들어갑니다.</p>
</section>
</section>
<section id="id11">
<h2>컨디션 변수 사용 시 주의점<a class="headerlink" href="#id11" title="Link to this heading">#</a></h2>
<div class="highlight-notice notranslate"><div class="highlight"><pre><span></span>팁 : 조건에 while 문을 사용하자 (if 문은 아니다) 멀티 쓰레드 프로그램에서 조건을 검사할 때에는 항상 while 문을 사용하는 것이 옳다. 시그널 전달의 의미에 따라 if 문을 사용하는 것은 맞을 수도 있을 뿐이다. 그러 므로 항상 while 문을 사용하자, 그러면 작성한 코드가 의도한 대로 동작할 것이다. 조건 검사에 while 문을 사용하는 것은 거짓으로 깨운 경우 (spurious wakeup) 에 대처할 수 있도록 해 준다. 어떤 쓰레드 패키지는 구현상의 문제로 하나의 시그널에 의해서 두 개의 쓰레드가 깨어나는 경우도 가능하다. 쓰레드가 조건을 재검사해야 하는 이유는 거짓으로 깨운 경우가 있기 때문이다.
</pre></div>
</div>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>//<span class="w"> </span>몇<span class="w"> </span>byte나<span class="w"> </span>힙이<span class="w"> </span>비었는가?
int<span class="w"> </span><span class="nv">bytesLeft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>MAX_HEAP_SIZE<span class="p">;</span>
cond_t<span class="w"> </span>c<span class="p">;</span>
mutex_t<span class="w"> </span>m<span class="p">;</span>

void<span class="w"> </span>*allocate<span class="o">(</span>int<span class="w"> </span>size<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="o">(</span>bytesLeft<span class="w"> </span>&lt;<span class="w"> </span>size<span class="o">)</span>
<span class="w">		</span>Pthread_cond_wait<span class="o">(</span><span class="p">&amp;</span>c,<span class="w"> </span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span>void<span class="w"> </span>*ptr<span class="w"> </span><span class="o">=</span><span class="w"> </span>.<span class="w"> </span>.<span class="w"> </span>.<span class="w"> </span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>힙에서<span class="w"> </span>메모리를<span class="w"> </span>할당<span class="w"> </span>받음
<span class="w">	</span>bytesLeft<span class="w"> </span>−<span class="o">=</span><span class="w"> </span>size<span class="p">;</span>
<span class="w">	</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span>ptr<span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>free<span class="o">(</span>void<span class="w"> </span>*ptr,<span class="w"> </span>int<span class="w"> </span>size<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">	</span>Pthread_mutex_lock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="w">	</span><span class="nv">bytesLeft</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>size<span class="p">;</span>
<span class="w">	</span>Pthread_cond_signal<span class="o">(</span><span class="p">&amp;</span>c<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>시그널<span class="w"> </span>전달<span class="w"> </span>대상은?..
<span class="w">	</span>Pthread_mutex_unlock<span class="o">(</span><span class="p">&amp;</span>m<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>멀티 쓰레드 기반 미모리 할당 라이브러리 예제입니다. 메모리 할당 코드를 호출하면, 공간이 생길 때까지 기다려야 할 수 있습니다. 또 쓰레드가 메모리 반납시 사용 가능한 메모리 공간의 발생을 알리는 시그널을 생성할 수 있습니다. 하지만 이 코드에는 문제가 있다 어떤 쓰레드가 깨어나야 할까요?</p>
<p>쓰레드 Ta는 100을 할당받길 원하고, 쓰레드 Tb는 10을 할당받길 원하는 상태에서, 어떤 쓰레드가 50만큼 메모리를 반환한 경우, Ta가 깨어나면 안 되고 Tb가 깨어나야 합니다. 이런 문제는 두 개의 컨디션 변수를 사용해도 해결할 수 없습니다.</p>
<p>Lampson과 Redell이 제시한 해법은 단순합니다. <code class="docutils literal notranslate"><span class="pre">pthread_cond_signal()</span></code>을 대기 중인 모든 쓰레드를 깨우는 <code class="docutils literal notranslate"><span class="pre">pthread_cond_broadcast()</span></code>로 바꿔서 사용하면 된다. 그렇게 함으로써 깨어나야 할 쓰레드가 있다면 깨어날 수 있도록 합니다. 그렇게 깨어난 쓰레드들은 깨어나서 조건을 재검사하고, 즉시 대기 상태로 다시 들어갑니다.</p>
<p>Lampson과 Redell은 이런 경우를 포함 조건(covering condition)이라고 했습니다. 왜냐하면 (보수적으로) 쓰레드가 깨어나야 하는 모든 경우를 다 포함하기 때문입니다. 불필요하게 많은 쓰레드가 깨어나는 단점이 있습니다. 문맥 전환 오버헤드가 큽니다. 예리한 독자라면 이 방법을 앞에서 사용했을 수도 있다는 것을 알 것입니다 (컨디션 변수를 하나만 사용하는 생산자/소비자 문제를 보자). 하지만 그 경우에는 더 좋은 해법이 있었기 때문에 그 방법을 택했습니다. 일반적으로 시그널을 브로드캐스트 (broadcast)로 바꿨을 때만 프로그램이 동작한다면 아마도 버그가 존재하는 것입니다. 앞서 다룬 메모리 할당 문제의 경우 브로드캐스트를 적용하는 것이 가장 자명한 해법입니다.</p>
</section>
<section id="id12">
<h2>요약<a class="headerlink" href="#id12" title="Link to this heading">#</a></h2>
<p>락 이상으로 중요한 동기화 기법인 컨디션 변수를 소개하였습니다. 프로그램 상태가 기대한 것과 다를 경우 쓰레드가 대기하도록 하여 컨디션 변수는 주요 동기화 문제 몇 가지를 깔끔하게 해결할 수 있습니다. 그 해법에는 그 유명한 생산자/소비자 그리고 포함 조건 문제도 포함합니다.</p>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="ypilseong" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/ypilseong">양필성</a></p>
</aside>
</aside>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "chu-aie/os-2024",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./week12"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="index.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Week 12 - 병행성 3</p>
      </div>
    </a>
    <a class="right-next"
       href="threads-sema.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">세마포어</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">정의와 루틴들</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">첫 번째 케이스</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">두 번째 케이스</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">생산자/소비자 (유한 버퍼) 문제</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">첫 번째 문제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#if-while">해결 방법: if -&gt; while</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">두 번째 문제</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">단일 버퍼 생산자/소비자 해법</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">최종적인 생산자/소비자 해법</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">컨디션 변수 사용 시 주의점</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">요약</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By <a href='https://entelecheia.me/'>Young Joon Lee</a>
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <script
  data-embed-id="8f8d1c1a-0e3e-428a-a8a6-26acd215e1fe"
  data-base-api-url="https://chat.entelecheia.app/api/embed"
  data-brand-image-url="https://assets.entelecheia.ai/favicon.png"
  data-chat-icon="magic"
  data-sponsor-text="OS 2024"
  data-sponsor-link="https://chat.entelecheia.app/workspace/os2024"
  src="https://chat.entelecheia.app/embed/anythingllm-chat-widget.min.js">
</script>

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>